# 3D 绘图简介

<Wisdom words="成长的关键是将更高维度的意识引入我们的意识中。" author="老子" />

每个 Metal 的介绍都是从渲染由三角形组成的 2D 形状开始的。这是呈现框架的移动部分以使图像出现在屏幕上的好方法。当你从设计的 2D 项目转向真实的 3D 项目时，你会引入所有 3D 项目固有的复杂性，无论框架如何。本章向你介绍从二维跳转到三维时需要理解的概念。

## 模型-视图-投影转换

3D 图形的一个重要方面是能够表示空间中与相机相关的对象。如果你在现实世界中考虑这一点，那么你的眼睛就是你的相机。如果你在商店里走动，当你走过时，货架会在你的视野中移动。如果你正在打篮球并且正在寻找传球的人，其他球员会在你周围的空间中移动。当你传球时，球会远离“摄像机”3D 图形面临的部分挑战是找到一种在虚拟世界中表达这些现实的方法。

在学会走路之前，你需要先学会爬行。以下部分介绍如何从相机的角度呈现虚拟世界。后面的部分涉及运动和重叠对象。在理解这些概念之前，你需要很好地掌握屏幕上呈现的内容。这些转换的数学公式在第 4 章“图形基础数学”中描述。

所有顶点数据都从对象空间开始。对象空间关注的是每个顶点在其自身上下文中如何与其他顶点相关。如果你查看顶点文件中的位置数据，它描述了对象空间中的位置。顶点着色器使用模型矩阵获取顶点数据并在对象空间中组装一个对象，然后将其传递到该过程的下一步，即世界空间。图 9.1 说明了转换和流程。

<Figure
  src={require("../figures/025.jpg")}
  num="9.1"
  desc="从物体空间移动到眼睛空间再到剪辑空间"
/>

复杂的 3D 场景可能在一个场景中包含数百个不同的对象。每个对象都需要表示为相对于世界空间中的原点的位置。在苹果的一个示例项目中，有数百个旋转立方体漂浮在太空中。这些立方体都是同一对象的实例，但它们具有自己独特的属性，例如颜色和位置。世界空间的目的是在这个空间内组合这些对象，就像放置顶点来组合对象一样。

在第 4 章中，我们向你介绍了矩阵变换。矩阵用于将顶点从对象空间重新定位到世界空间。模型文件描述了每个顶点在对象空间中的定位方式。当顶点通过顶点着色器时，模型文件中描述的变换将应用于该顶点，以将其正确定位在世界空间中。该任务是使用视图矩阵完成的。

视图矩阵将对象从世界空间转换到眼睛空间。此平移将原点从对象的中间重新定向到相机位置。通常，模型矩阵和视图矩阵被组合成模型-视图矩阵。尽管模型视图矩阵是任何实现 3D 的 Metal 程序的必要组件，但 Metal 并不包含其内置实例。它并不假定知道你将如何选择放置对象，因此它让你自行决定。以下实现只是如何实现模型视图矩阵的一个示例：

struct Matrix4x4 { var X: Vector4 var Y: Vector4 var Z: Vector4 var W: Vector4

init() { X = Vector4(x: 1, y: 0, z: 0, w: 0) Y = Vector4(x: 0, y: 1, z: 0, w: 0) Z = Vector4(x: 0, y: 0, z: 1, w: 0) W = Vector4(x: 0, y: 0, z: 0, w: 1) }

static func spinAboutAxis(\_ axis: Vector4, byAngle 角度: Float32) -> Matrix4x4 { var mat = Matrix4x4()

令 c = cos(角度)

让 s = sin(角度)

mat.X.x = axis.x _ axis.x + (1 - axis.x _ axis.x) _ c mat.X.y = axis.x _ axis.y _ (1 - c) - axis.z _ s 垫 X.z = 轴.x _ 轴.z _ (1 - c) + 轴.y \* s

mat.Y.x = axis.x _ axis.y _ (1 - c) + axis.z _ s mat.Y.y = axis.y _ axis.y + (1 - axis.y _ axis.y) _ c Y.z = 轴.y _ 轴.z _ (1 - c) - 轴.x \* s

mat.Z.x = axis.x _ axis.z _ (1 - c) - axis.y _ s mat.Z.y = axis.y _ axis.z _ (1 - c) + axis.x _ s mat.Z.z =轴.z _ 轴.z + (1 - 轴.z _ 轴.z) \* c

返回垫 } }

该结构代表一个矩阵对象。它使用单位矩阵进行初始化，这是计算机图形学中矩阵的安全默认值。然后，你可以将默认值更改为基于程序员传入的轴和角度将轴计算为旋转角度的值。此操作会重置单位矩阵以创建一个新矩阵，为顶点着色器提供将对象从对象空间转换到眼睛空间所需的信息。

要实现这些更改，你需要选择旋转角度和旋转轴：

var spinAngle: Float32 = 0 让 yAxis = Vector4(x: 0, y: -1, z: 0, w: 0) var modelViewMatrix = Matrix4x4.rotationAboutAxis(yAxis, byAngle: 旋转角度)

### GLM 和其他数学库

大多数使用 OpenGL 的人不会推出自己的矩阵函数。有许多开源库，例如 OpenGL Mathematics (GLM)，它们可以与 OpenGL Shading Language (GLSL) 很好地配合并为你实现这些功能。虽然这些库目前不能直接与 Metal 一起使用，但它们是开源的，并且代码是 C/C++ 语言。当你开始图形编程时，它们是一种宝贵的资源，可以利用它们 — 它们可以为你提供帮助，就像在你创建第一个着色器程序时将 GLSL 代码转换为 Metal 一样。如果你感觉特别雄心勃勃，你可以根据数学库中找到的方程来做你自己的开源项目。

## 剪辑空间和视锥体

现在你已成功将原点转换为世界空间，你需要确定哪些对象主动出现在屏幕上。图 9.2 说明了视锥体如何确定剪辑空间内的内容。回想一下商店演练的例子。当你穿过商店时，你会经过货架。这些架子以一种不会根据相机朝向的位置而改变的方式相互存在，因此你有两个独立的原点。当这些架子不在你的视野中时，它们不会停止存在，但渲染当前不可见的对象将是对处理时间的严重浪费。平均而言，你只需 16 毫秒即可渲染每一帧。你希望将每一毫秒都奉献给人们会看到的事情。为此，你需要另一个矩阵来确定当前对象是否可见。该矩阵是*投影矩阵*。

<Figure
  src={require("../figures/026.jpg")}
  num="9.2"
  desc="将对象从眼睛空间转换到剪辑空间的视锥体"
/>

有两种不同的方法可以实现投影矩阵：

- **正交**丢弃场景中的所有深度感知并将其渲染为纯 2D。尽管正交投影是一种选择，但你更可能想要创建透视投影矩阵。
- **透视**投影矩阵将远处的物体渲染得更小，并保持所构建的世界空间的总体感觉。投影矩阵示例如下：

struct Matrix4x4 { var X: Vector4 var Y: Vector4 var Z: Vector4 var W: Vector4

init() { X = Vector4(x: 1, y: 0, z: 0, w: 0) Y = Vector4(x: 0, y: 1, z: 0, w: 0) Z = Vector4(x: 0, y: 0, z: 1, w: 0) W = Vector4(x: 0, y: 0, z: 0, w: 1) }

static func 透视投影（\_方面：Float32，fieldOfViewY：Float32，近：Float32，远：Float32） - > Matrix4x4 { var mat = Matrix4x4（）

让 fovRadians = fieldOfViewY \* Float32(M_PI / 180.0)

让 yScale = 1 / tan(fovRadians _ 0.5) 让 xScale = yScale / 方面 让 zRange = 远 - 近 让 zScale = -(远 + 近) / zRange 让 wzScale = -2 _ 远 \* 近 / zRange

mat.X.x = xScale mat.Y.y = yScale mat.Z.z = zScale mat.Z.w = -1 mat.W.z = wzScale

返回垫； } }

投影矩阵需要四部分信息才能正确计算：

- **纵横比**：宽度除以长度的比率。常见的长宽比为 4:3 和 16:9。比率根据 Metal 可拉伸件的尺寸而变化。
- **y 轴视野**：相机应用了多少“变焦”。
- **近平面**：赋予最近平面的值（通常接近 0）。近平面和相机之间的任何东西都不会被绘制。
- **远平面**：赋予视锥体“背面”的值。假设你正在看一个房间。远平面代表视锥体的后墙。远平面后面的任何东西都不会被绘制。

为了获得一个合适的投影矩阵，如图 9.3 所示，你需要获取当前可绘制对象的纵横比并将其传递到投影矩阵中。

<Figure src={require("../figures/027.jpg")} num="9.3" desc="精确的透视矩阵" />

让方面 = Float32(metalLayer.drawableSize.width) / Float32(metalLayer.drawableSize.height)

让 projectionMatrix = Matrix4x4.perspectiveProjection（方面，fieldOfViewY：60，近：0.1，远：100.0）

现在你已经有了一个面向世界和相机空间的场景，你需要将计算机图形编程中最重要的东西应用到它上面：照明。

## 着色模型

灯光是视觉媒体中最重要的概念之一。这就是看起来很棒的图像和看起来很糟糕的图像之间的区别。

想想你自己的各种照片。一个喝过酒的人在黑暗的酒吧里拍的照片会让你看起来老了几十岁，而且体重增加了 20 磅。优秀的摄影师会以讨人喜欢的方式打光你的脸。如果没有照明，你的模型将不会出现在屏幕上。充分了解各种照明算法和技术对于成为一名成功的图形程序员至关重要。了解算法的性能成本并权衡实现每种类型的成本和收益也很重要。

### 平面阴影

最简单且计算成本最低的着色方法是平面着色。它便宜又容易的原因和生活中任何事情的原因是一样的：它不是很好。平面着色用于根据多边形表面法线与光源方向之间的角度对对象的每个多边形进行着色。结果，每个面都均匀地着色为相同的颜色。如果脸部的一角靠近光源，则整个脸部都会被照亮，尽管其表现并不符合物理现实。

在所有可用的着色方法中，平面着色是最不真实且外观最差的。平面着色是街机视频游戏和早期家庭视频游戏系统的一个特征。直到 20 世纪 90 年代初，它一直是主要的遮阳系统。如果你希望图形具有复古感，请使用平面着色。

### 高洛阴影

20 世纪 90 年代初，平面着色很大程度上被 Gouraud 着色所取代 Gouraud 着色是第一个突出的平滑着色方法。如果你观察平面阴影，就会发现每种形状都有明显的面孔 Gouraud 着色可以平滑这些形状，并允许你创建外观更好的形状，而无需包含数千个多边形。

Gouraud 着色取决于插值，如图 9.4 所示。该算法获取每个顶点的光照，权衡每个顶点与其着色点的接近程度，并为其分配权重。然后，它根据该点相对于光源的位置来计算该点应具有多少照明。你在第 5 章“着色器简介”中实现的着色器使用了 Gouraud 着色，因为照明是按顶点计算的。

<Figure
  src={require("../figures/028.jpg")}
  num="9.4"
  desc="Gouraud 着色中照明的线性插值"
/>

### Phong 阴影

Phong 着色甚至比 Gouraud 着色更好。它不是计算每个顶点的照明，而是计算每个片段的照明，如图 9.5 所示 Phong 着色也依赖于线性插值，但它不仅仅依赖于每个顶点的照明。它根据插值法线和反射模型计算像素颜色 Phong 着色使用线性插值，而不是跨多边形插值。

<Figure
  src={require("../figures/029.jpg")}
  num="9.5"
  desc="Phong 着色中照明的线性插值。这种方法更准确，但需要更多处理。"
/>

Phong 着色比 Gouraud 着色更好，但它也更消耗处理器资源。特别是对于具有小镜面高光的反射模型，Phong 着色比 Gouraud 着色效果要好得多。如果你有特别大的多边形，并且镜面反射击中脸部的中间而不是任何顶点，则 Gouraud 着色模型将不会记录有要渲染的高光，并且高光将完全被渲染。丢失的。

## 基本照明

照明不仅仅是知道它是基于顶点还是基于片段计算。有几种不同类型的灯光会产生完全不同的效果 AAA 视频游戏或动画电影中最复杂的建模场景是由数十个（如果不是数百个）所有此类灯光的实例组成的。这不是一个非此即彼的选择。这是创建你想要的效果所需的每种类型的光的数量。

### 周围的

当你想到照明时，你通常会想到环境光。它向所有侧面施加均匀的光线。它不会投射阴影，只是为所有对象添加基本照明水平。如果你只想查看场景中发生的情况，这会很有帮助，但并不是特别有趣。

### 定向漫反射

环境光是在创建一般照明之前在多个表面反射的光。然而，现实世界中并非所有光的行为方式都是如此。在现实世界中，你有太阳或灯泡等光源。这些光源会先照射到你的物体，然后再反弹以产生环境光，你需要了解它们如何影响物体的外观。

漫射光往往给人一种柔和、模糊的感觉。想想如果你这样做会是什么样子

用手电筒对准网球。网球有一个模糊的、不规则的表面。该表面导致光线以混乱的方式散射。这会产生柔和的灯光效果，而不是你在镜子表面看到的锐利效果。

### 定向镜面

漫反射光和镜面反射光很相似，但也有细微的不同。两者都处理强点光源，但它们对它们的反应不同。漫射光像网球表面一样散射。镜面光的反应就像闪亮的表面。想象一个 Metal 球。如果你用手电筒照射球，球表面会以直接且刺眼的方式反射大部分光线，这与网球反射光线的柔和方式不同。

想想每个 J.J. 身上的镜头光晕。艾布拉姆斯的电影。相机平移经过光源。光线短暂地穿过屏幕并遮挡屏幕上的所有其他物体。这是镜面光源的示例。它是穿过相机视野的明亮闪亮的光点。

照明不仅仅涉及位置。这是关于如何模拟自然世界中光的反应方式。通过确定光源对对象的镜面反射或漫射程度，你可以指示可以使用什么类型的材料创建它们。

## 动画片

运动是交互式计算机图形学不可或缺的一部分。如果场景中没有任何东西在移动，那么它只不过是一件静态的艺术品。用户将与你的应用程序交互，并且应用程序将响应他们。这涉及到运动，了解其工作原理很重要。本节绝不是全面的。有一些长达数百页的书籍描述了计算机动画。本节仅简要概述启动和运行所需了解的内容。

你可以实现的最简单的动画类型是基于帧的动画。在大多数游戏中，都有一个游戏循环。该循环在每一帧上都会被调用，并且所有游戏逻辑、动画等都必须在设定的时间内执行，以保持良好的帧速率。如果你将动画调用置于此循环中，则将一致地调用你的动画。但是，如果循环速度减慢或运行不一致，则可能会出现问题。你的动画在较旧且功能较弱的机器上运行速度会慢得多，这意味着你的用户将获得完全不同的体验。如果将动画调用与游戏循环联系起来，你的角色运动也会看起来不均匀。

制作动画的更一致的方法是通过插值，其中涉及关键帧。_关键帧_ 是动画过程中发生重要事件的点。假设你正在制作一辆汽车的动画。汽车开始移动的帧和汽车停止移动的帧是动画的关键帧。为了确保这两个事件之间的动画一致，算法会计算汽车在关键帧之间每帧必须移动的距离。计算这些中间帧的过程称为 _补间_。

汽车是一个物理对象。汽车需要一些时间才能加速。同样，汽车也需要一些时间才能慢下来。如果汽车立即从 0 到 60 或从 60 到 0，这将是一个不自然的动画。要逐渐增加或减少运动，可以使用缓动方程，如图 9.6 所示。为了让汽车加速，你可以使用二次缓入。

要减慢汽车速度，你可以使用缓出功能。缓动方程使你能够模拟自然的运动。

<Figure src={require("../figures/030.jpg")} num="9.6" desc="动画的缓入和缓出" />

## 概括

从 2D 过渡到 3D 时，你需要考虑很多信息。你必须计算屏幕的长宽比，并将模型从对象空间转换为世界空间再到剪辑空间。你必须考虑如何照亮场景并权衡不同着色模型的成本和收益。此外，你必须确定最适合你的图形的动画方法。
