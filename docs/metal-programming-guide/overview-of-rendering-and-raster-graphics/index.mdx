# 渲染和光栅图形概述

<Wisdom
  words="操纵现实的基本工具是操纵文字。如果你能控制词语的含义，你就能控制必须使用它们的人。"
  author="菲利普·K·迪克"
/>

Metal 代码的最终结果是将图像渲染到屏幕上。但它是如何到达那里的呢？ Metal 如何获取大量数据并将其转换为你可以看到的内容？

许多一开始对 3D 图形编程感兴趣的人发现自己淹没在未知的海洋中。什么是*着色器*？什么是*缓冲区*？所有这些数字代表什么？

我们对 3D 图形工作原理的思考方式与计算机对 3D 图形工作方式的思考方式截然不同。我们可以想象拿起一支蜡笔在一张纸上画一个简笔画，但这不是计算机的工作方式。作为程序员，我们有责任以计算机可以理解的方式格式化我们的指令。

本章让你更好地了解计算机如何获取数据并将其转换为你可以在屏幕上看到的内容。

## 代表 GPU

本书的重点以及你需要理解的所有概念的基础都回到了图形处理单元（GPU）。整本书都是围绕如何对 GPU 进行编程展开的，因此清晰地解释 Metal 如何表示 GPU 以及程序员如何与其交互是有意义的。

GPU 在 Metal 中由符合 MTLDevice 协议的对象表示。 MTLDevice 负责创建和管理各种持久性和瞬态对象，用于处理数据并将其呈现到屏幕上。有一个方法调用可以创建默认系统设备，这是 GPU 在软件中表示的唯一方法。这可以确保向 GPU 发送数据或从 GPU 发送数据时的安全性。

MTLDevice 允许你创建命令队列。队列保存命令缓冲区，而缓冲区又包含为 GPU 附加命令的编码器。如果这有点令人困惑，请不要担心；本章对此进行了详细描述。

命令缓冲区存储渲染帧所需的指令。这些指令包括设置状态的命令（控制绘制的完成方式）以及导致 GPU 执行实际渲染工作的绘制调用。这些是一次性的临时对象。一旦缓冲区的工作被执行，缓冲区就会被释放。

命令被编码在命令缓冲区中。每个命令都按照其入队的顺序执行。一旦所有命令都入队，命令缓冲区就被提交并提交到命令队列。

命令队列接受 GPU 将执行的命令缓冲区的有序列表。

命令缓冲区按照它们提交到命令队列的顺序执行。命令队列的创建成本很高，因此当它们执行完当前指令后，它们会被重用而不是被销毁。

现在基础工作已经奠定，让我们探讨一下它是如何工作的。

**渲染状态配置**

我们可以将 Metal 完成的工作概念化为一系列在某种渲染管道中链接在一起的转换。管道执行一系列步骤来准备供 GPU 处理的数据（如图 2.1 所示）：

1. GPU 的数据准备
2. 顶点处理
3. 图元组装
4. 片段着色
5. 光栅输出

<Figure
  src={require("../figures/004.jpg")}
  num="2.1"
  desc="数据到达屏幕的路径"
  size={480}
/>

创建 Metal 的动机之一是将 CPU 成本高昂的工作移至渲染过程的开始，而不是强迫程序支付不必要的成本。这些任务之一是状态验证过程。

Metal 使用 MTLRenderPipelineState 协议。渲染管道状态对象包含可以在渲染命令编码器上快速设置的状态集合，允许你避免调用许多状态设置方法，另外确保你设置的状态在内部一致，因为它是在当时验证的管道已创建。 MTLRenderPipelineDescriptor 具有允许你配置如何创建渲染管道状态对象的属性。

MTLRenderPipelineDescriptor 设置预验证状态。这项工作不是在每次绘制调用时检查状态是否有效，而是转移到描述符的创建上。

可以预先验证的管道状态包括以下设置：

- 指定着色器函数 - 附加颜色、深度和模板数据 - 光栅和可见性状态 - 曲面细分状态

然后可以将 MTLRenderPipelineState 传递给命令编码器。由于 Metal 知道渲染状态是有效的，因此它不需要在每次绘制调用时不断引用它，从而消除了昂贵且不必要的步骤。

**为 GPU 准备数据**

你将用于创建 3D Metal 应用程序的大多数资源都来自 Blender 或 Maya 等程序。这些数字内容创建程序创建格式化文件，其中包含描述你尝试创建的任何模型的顶点信息。

它描述了形状中每个顶点的位置和颜色。它描述了如何连接这些顶点以生成创建 3D 模型外观的网格。

该顶点信息作为值数组引入你的 Metal 程序中。这可以通过几种不同的方式来完成。如果 Apple 的 Model/IO 框架支持该文件格式，你可以使用该框架导入模型。如果不是，你可以编写自己的文件解析器。你甚至可以手动将所有顶点数据输入到应用程序中，但这种方法很快就会变得难以承受。

应用程序现在需要一种方法来理解这些值数组是将发送到 GPU 以在屏幕上生成图像的数据，因此你需要将命令编码到命令缓冲区。

有四种方法可以对命令缓冲区的数据进行编码：

- MTLRenderCommandEncoder - MTLComputeCommandEncoder - MTLBlitCommandEncoder - MTLParallelRenderCommandEncoder

你可以根据你希望 GPU 执行的工作类型来选择所需的命令编码器类型。在本章中，我们将重点关注图形方面，因此我们将重点关注 MTLRenderCommandEncoder。其他编码器在与其功能相关的章节中进行了介绍。

渲染编码器需要为顶点和片段着色器准备数据源。这个可以

以缓冲区的形式完成。要以 GPU 可以理解的方式准备这些顶点数组，你需要创建使用这些数组作为数据源的顶点和片段缓冲区。缓冲区还需要分配足够的内存来保存顶点值数组。

有关如何完成此操作的更多信息，请参阅第 8 章“2D 绘图”。

**顶点着色**

为了执行渲染，你的应用程序必须创建一对函数，每个函数都有自己独特的职责。顶点着色器和片段着色器是同一程序的两个部分；它们不是两个独立的事物。

顶点着色器负责计算每个顶点的位置（见图 2.2）。它确定顶点在框架内是否可见。至少，顶点着色器将接收每个顶点的位置数据。它还可以接收其他信息，例如纹理坐标。它可以按顶点或按对象基元接收此数据。对象基元用于实例化绘图。

<Figure
  src={require("../figures/005.jpg")}
  num="2.2"
  desc="图形渲染管线中每种着色器类型的工作"
/>

图形函数（如顶点函数和片段函数）具有一个参数列表，用于枚举它们所操作的资源。这些参数通过称为“参数表”的抽象绑定到应用程序创建的缓冲区和纹理对象。参数将传递到着色器中，因此当你编写着色器应用程序时，传入的参数必须与参数表中存在的参数相关联。

顶点着色器接收已为 GPU 准备的数据。这些顶点设置在

稳定地馈送到着色器程序的流，其中每个顶点一次处理一个。然后，着色器程序处理该数据并将其传递以组装成基元。你在绘制调用中引用的每个顶点都会调用顶点着色器，因此优化程序的一种方法是使用具有尽可能少顶点的模型。

着色器是用 Metal Shading Language (MSL) 编写的小程序。 MSL 基于 C++14 的子集。它包括一些标准数据类型，例如整数和浮点数，但它也有一些专门的内置数据类型和函数，例如点，它们对于矩阵运算很有用。

Metal 有许多内置类来确定顶点数据如何存储在内存中以及如何将其映射到顶点着色器函数的参数。

**剪裁**

在 Metal 中，你需要了解两个概念世界：世界空间和相机空间。

想一想当你看电影的时候。你看到演员和家具，但这些并不是那个空间里唯一的东西。摄影机范围之外有灯光、演播室观众和电影摄制组。

GPU 渲染任何未出现在屏幕上的形状是没有意义的。可以创建存在于视野之外的模型和形状。这些物体可能会移入或移出视野。

Metal 应用程序将进行的一项优化是确定形状是否出现在视野内。它还将确定形状是否被部分遮挡以及仅部分显示在屏幕上。

如果某个图元根本不存在于相机空间内，则该图元将被剔除。例如，如图 2.3 所示，如果永远不会看到顶点的不面向相机的面，通常会剔除该面。它根本没有被渲染，程序继续前进。

<Figure
  src={require("../figures/006.jpg")}
  num="2.3"
  desc="决定能见度的“舞台”"
/>

但是，如果图元部分可见，则图元将被剪裁。将三角形修改为符合裁剪空间的多边形，并将多边形分解为新的三角形，如图 2.4 所示。

<Figure
  src={require("../figures/007.jpg")}
  num="2.4"
  desc="任何未出现在屏幕上的内容都会被剔除。此过程有时会导致重新三角测量。"
/>

在程序确定什么是可见的、什么是不可见之后，数据被传递到光栅化器进行图元组装。

**原始装配**

顶点着色器处理完顶点数据后，需要将该数据组装成图元。

Metal 支持三种基本类型的基元：

- **点**：由一个顶点组成 - **线**：由两个顶点组成 - **三角形**：由三个顶点组成

在绘制调用中，你告诉 GPU 你要绘制什么类型的图元。它创建这些顶点的集合并将它们构造成每种基本类型。这些形状被转换为一系列需要着色并输出到屏幕的像素。

然后对这组像素进行光栅化。

**光栅化**

渲染围绕着对图像在屏幕上的显示方式进行建模。它不仅仅涉及形状和基元。它还与建模光线如何在场景中散射以及如何与场景中的对象交互有关。

传统上，有两种将此数据渲染到屏幕上的方法：光线追踪和光栅化。这些方法虽然方法相似，但从相反的方向处理问题。

光线追踪扫描帧中的每个像素，直到它与某物相交。光线与任何物体相交的颜色就是像素将被记录的颜色。如果图元位于其他对象后面，则它们不会在屏幕上渲染；光线在到达阻挡物体之前会停止并返回颜色。

光栅化采用相反的方法。就像 20 世纪 90 年代教师使用的老式高射投影仪一样，光栅化将图元投影到屏幕上，而不是从后面扫描物体。然后它循环遍历像素并检查像素中是否存在对象。如果是，则像素将填充对象的颜色。

**片段着色**

片段着色器负责确定帧中每个像素的颜色。每个像素都是红、绿、蓝的组合。人类能看到的大多数颜色都可以表示为红色、绿色和蓝色的某种组合。如果每种颜色都处于全强度，则屏幕上看到的颜色将为白色。如果每种颜色都没有强度，则颜色将为黑色。

有一个最终值，即 _alpha_ 值，它表示透明度。如果你的对象完全不透明，则 alpha 值为 1。如果你的对象是可以部分透视的气球，则 alpha 值约为 0.8。如果你有一个完全透明的对象，则 alpha 值将为 0。

如果没有光照或滤镜或其他效果应用于对象，则片段着色器需要一个简单的传递程序，该程序接收并返回由光栅化器传递到着色器的颜色。

如果（更常见的是）你想要添加照明或其他效果，片段着色器将计算如何确定像素的颜色。此外，如果你正在对对象进行纹理映射，片段着色器也会管理该任务。

假设你有一个均匀绿色的网球。如果你用灯光照射网球，灯光会呈现出原始绿色的渐变色调。为了准确地模拟光线的效果，片段着色器会计算像素距光源的距离、光线的强度以及表面的光泽程度。这些计算使程序能够模拟光表面相互作用。

片段着色器返回每个像素的红色、绿色、蓝色和 alpha 值的数据表示形式，并将其沿着管道传递。片段着色器是在将图像数据发送到帧缓冲区输出之前修改图像数据的最后一站。

**光栅输出**

在图像输出到屏幕之前，它首先经过帧缓冲区。无论你优化渲染调用的速度有多快，GPU 仍然需要一定的时间来绘制数据以进行光栅化。如果你直接在屏幕上绘制，就会出现闪烁，质量也会很差，这显然是你不希望看到的。

图像不是尝试直接绘制到屏幕，而是合成并存储在帧缓冲区中。在任何给定时间点至少有两个帧缓冲区。一个正在主动呈现到屏幕上，而另一个则被吸引到，如图 2.5 所示。

<Figure
  src={require("../figures/008.jpg")}
  num="2.5"
  desc="帧缓冲区交换。当其中一个被吸引时，另一个正在被呈现。"
/>

帧缓冲区标记组，以便始终将帧呈现在屏幕上。这确保了无缝的用户体验。当向用户显示前一帧时，它还可以释放 GPU 来继续渲染。如果没有双缓冲或三缓冲，你实际上无法在 GPU 上执行任何工作，因为你没有地方可以放置渲染数据。

## 概括

我们人类概念化图形的方式纯粹是视觉的。然而，计算机必须用数字表示图像。为了让计算机理解图像应该是什么样子，我们必须以计算机可以理解的方式格式化信息。

3D 图像被分成三角形。这些三角形是使用顶点来描述的。这些顶点被写入顶点缓冲区并馈送到顶点着色器。然后，计算机确定三角形是否出现在屏幕上。它会剔除任何未出现的对象。然后，片段着色器会对这些对象进行细化，并在其中应用效果。最后，描述每个像素的数据被发送到帧缓冲区，在图像呈现到屏幕之前在帧缓冲区中绘制图像。
