# 机器视觉

<Wisdom
  words="谢谢，运动传感器擦手巾机。你从不工作，所以我最后看起来就像是在向墙上的机器人挥手打招呼。"
  author="Jimmy Fallon"
/>

在过去 10 年里，Instagram 和 Snapchat 等图像处理应用程序席卷了科技界。然而，简单的卡通滤镜让你留出小胡子，这只是图像处理的冰山一角。机器视觉算法是许多当前和不断发展的创新的背后，例如自动驾驶汽车和亚马逊的即买即走杂货店。本章介绍了一些常见的机器视觉算法以及它们如何改变世界。

## 计算机如何看待世界

花点时间环顾四周。你看到了什么？你需要多长时间才能认出周围的物体？当你看到这本书的副本时，你不仅知道它是一本书，而且还知道它是《Metal 编程指南》的副本，而不是《为了乐趣和利润而饲养哈巴狗》。你可能无法清楚地表达为什么你知道这是一本书，因为它只是一本书。我们的大脑极其复杂。我们能够直观地处理某些东西，并通过我们仍然不完全理解的复杂神经网络自动知道它是什么。

计算机以不同的方式看待事物。计算机看不到书籍封面上的不同颜色或拼出标题的字符。计算机在任何给定时刻都会看到图像的红色、蓝色和绿色强度的一系列数值。机器视觉的艺术和科学为计算机提供了一些工具和背景，以便它能够理解这些值的含义。

机器视觉的总体思想是 _特征检测_。特征检测可以像检测边缘在哪里一样简单，也可以像确定图片中的动物是否是哈巴狗一样复杂。更复杂的算法建立在更简单的算法之上，因此本章的结构从简单的机器视觉概念到更复杂的概念。

## 噪声和平滑

如果我们每次拍照都能拍出完美的照片，那就太好了，但不幸的是，世界密谋反对我们。低光照、相机质量差和环境因素可能会导致图像质量差。含有噪声的图像会降低机器视觉算法的准确性。如果在卷积核中评估的像素不能代表该给定点的颜色，它可能会混淆算法，如图 17.1 所示。

<Figure
  src={require("./17_1.jpg")}
  num="17.1"
  desc="平滑如何工作"
  size={420}
  edge="white"
/>

第 16 章“Metal 中的图像处理”向你介绍了高斯模糊滤镜。模糊是很酷的效果，但它们在机器学习中也发挥着至关重要的作用。如果图像有噪声，可以使用模糊来平滑图像，从而消除噪声。这是由于卷积核中的加权像素值而起作用的。如果存在椒盐噪声，则任何给定的像素都可能随机错误。通过对像素进行平滑处理并平均其权重，你可以减轻任何单个像素对图像的影响。

另一种实现平滑的算法是 _中值滤波器_。中值滤波器与模糊形成鲜明对比，因为模糊通过将所有值加在一起并除以这些值来找到平均数，从而利用像素的平均值。中值滤波器选择周围像素的中间代表值。这对于较小的图像效果更好，其中离群像素在加权内核中可能具有不成比例的权重。中值滤波器会忽略那些超出中值太远的像素。

你可以用来平滑图像的最后一种算法是“双边过滤”。双边滤波比其他平滑算法的优势在于它保留了边缘。高斯平滑假设像素之间的颜色将保持相当一致，而亮度不会出现大的跳跃。这通常是正确的，但当你处理边缘时，它就站不住脚了，边缘的定义特征是亮度的大幅跳跃。

双边过滤有两个步骤。第一步是前面提到的相同的高斯滤波。第二步也是高斯加权，但它不是基于距样本像素的距离。第二步中的加权基于与中心像素的强度差。亮度与采样像素更相似的像素比亮度相差很大的像素的权重更大。

## Sobel 边缘检测

你将在本章中学习的第一个机器视觉算法是 _Sobel 边缘检测_。边缘检测是机器视觉的一个很好的起点，而 Sobel 边缘检测是对特征检测的相对温和的介绍。

批判性地思考如何检测图像中的边缘。边缘是颜色从亮到暗或从暗到亮快速变化的区域。每个像素都有一组颜色值。你可以通过查看这些值来确定像素的相对亮度。更重要的是，你可以将这些值与它们周围的值联系起来。如果你有一个明亮的像素，并且它左侧的每个像素都明显变暗，则表明该像素是某个特征的一部分。

由于边可以垂直或水平移动，因此有必要运行两次 Sobel 操作。第一个检查水平边缘，如图 17.2 所示。

<Figure
  src={require("./17_2.jpg")}
  num="17.2"
  desc="水平和垂直索贝尔内核"
  size={220}
  edge="white"
/>

如果样本像素两侧的像素具有相似的亮度，则权重会相互抵消，并且没有边缘。如果任一侧的像素明显更暗或更亮，则该差异会反映在权重中。然后，还在内核中的顶部和底部行像素上执行此操作，以检查垂直空间中的边缘。

着色器创建变量来保存卷积核中周围像素的强度 _h_ 变量保存水平核运算的结果，并将所有权重应用于这些值 _v_ 变量保存垂直核运算的结果，以及应用的权重 _h_ 和 _v_ 被视为可以计算其间矢量长度和幅度的点。该大小以颜色值的形式返回。

## 阈值

Sobel 边缘检测对于机器视觉来说并不是真正有用。对于给定像素是否位于边缘，不存在二元是或否。这就需要一个门槛。

_阈值_ 在概念上相当简单。你选择一个参数（通常是亮度）来与阈值进行比较。在 8 位图像中，阈值可以是从 0 到

255、如果当前像素比阈值亮，则选择该像素。如果该值较低，则不选择该像素。阈值生成二进制图像，其中每个像素要么是黑色，要么是白色。有些东西要么被选择，要么没有被选择。正如你将在本章中看到的那样，这在机器视觉中很有用。创建一个将像素分为两组之一的过滤器，可以让 GPU 更轻松地处理它们。像素要么收到效果，要么不收到效果。这是一个构建块，用于产生更复杂和有用的效果。

阈值处理有一种变体，称为“自适应阈值处理”。在非自适应阈值处理中，所有像素都以相同的方式处理并根据相同的参数进行测量。没有

考虑像素是背景的一部分还是前景中大型照明物体的一部分。通常，你会希望根据像素组相对于它们周围的像素以及你所表示的空间中的对象的位置来以不同的方式处理像素组。

幸运的是，应用自适应阈值处理利用了你已经熟悉的概念：卷积。要创建自适应阈值，请将高斯分布应用于周围的像素。这使你能够提高灵活性，防止从正在处理的图像中删除对比度和细节。

## 直方图

如果你曾经使用过 Photoshop，你就会熟悉直方图。在 Photoshop 中，直方图中图像的视觉表示可以让你了解图像中最暗和最亮部分的集中位置。它允许你根据该浓度增强图像的某些光谱，以平衡图像的色彩。这只是直方图的一种用途。

直方图是对图像的复合元素进行分类的一种方法 8 位灰度图像的每个像素可以有 256 个不同的值。直方图检查图像中的每个像素并报告图像中存在每个值的像素数。这些值可以按值带捆绑在一起，例如 0-15、16-30 等，以便更轻松地分析具有大量值的图像。直方图并不是图像所独有的。任何数据，例如目前六年级女孩的身高，都可以记录并分类成直方图。

直方图对于图像处理和机器视觉很有用。你可以使用直方图来检查图像之间和图像内的差异。你可以通过查找具有较高直方图值的区域来检查感兴趣的区域。当你了解人脸检测时，本章稍后会使用直方图。

## 面部识别

机器视觉的一个主要领域是面部识别。面部识别可以像你的相机扫描视野一样简单，寻找图像的焦点，从而能够识别场景中存在的每个人。一般来说，所有面部识别算法都属于以下四种策略之一：

- **自上而下和基于规则**：程序员创建一组面部遵循的规则，例如具有代表眼睛和鼻孔的对称对象。由于人类信息不完善，这种方法有其局限性。这些规则受到程序员对面部构成以及图像在什么条件下创建的固有理解的限制。
- **自下而上和基于特征**：在这种方法中，程序员描述可能构成面部的区域。这些包括嘴唇、肤色区域等。这些被提取并用于尝试重建面部。这种方法容易受到噪声和阴影遮挡的影响。
- **模板匹配**：这种方法创建面部模板。模板可以包括轮廓的表示或与图像进行比较的各种面部区域的合成。这种方法的弱点在于它难以有效地处理尺度、姿势、方向和形状的变化。
- **基于外观的建模**：这种方法是唯一一种不单独定义的方法

人类。它将模板匹配与机器学习结合起来。计算机会获得一个模板，用于在大型数据集中搜索可能是人脸的对象。它向用户显示其“猜测”，用户拒绝不是面部的物体，从而教会机器面部识别的细微差别。这是最有效的方法，第 18 章“神经网络概念”中有更详细的介绍。

### 维奥拉-琼斯物体检测

2001 年，Paul Viola 和 Michael Jones 提出了一种新的对象检测方法，后来被称为“Viola-Jones 对象检测框架”。该框架最初并不是专门针对人脸检测的。它是为一般物体检测而设置的。它被证明是当时最有效的人脸检测算法，并成为人脸识别领域的基础。

基本上，该框架利用特征提取来提取一个区域进行分析，如图 17.3 所示。它将这个区域转换为可以分析的值，并返回一个答案（是或否），说明所提取的特征是否是你要检查的特征。如果你看过《硅谷》第四季，Jian-Yang 构建了一个对象检测框架来告诉你所提取的特征是否是热狗。这是利用该算法的一种方法，但不一定是最好的方法。该算法有四个阶段：

- Haar 特征选择
- 创建积分图像
- AdaBoost 训练
- 级联分类器

<Figure
  src={require("./17_3.jpg")}
  num="17.3"
  desc="特征提取如何工作"
  size={420}
  edge="white"
/>

以下部分详细介绍了每个步骤如何融入该流程。预先警告，这些是极其复杂的数学概念。本书并没有讨论所有这些复杂性，而只是提供了如何处理和解决这个问题的高级概述。

### 哈尔特征选择

想想一张脸。面部的某些部分往往相似并且位于面部的相似区域。每个人都有眼睛（或者至少是脸部的指定区域）。眼睛通常位于下巴上方约三分之二的位置。人的鼻子位于脸部的中间。如果你要分析图像以查看它是否是一个人的照片，你可以利用这些知识来检查感兴趣的区域以查看它们是否是面部特征。

_Haar 特征_ 是图像的矩形区域。它们如图 17.4 所示。这些矩形既有透明部分又有阴影部分。阴影部分包含

感兴趣的领域。从阴影矩形所包含的像素值的总和中减去透明矩形所覆盖的像素值的总和。

对于脸部的不同部位，Haar 特征有几种不同的风格：

- **双矩形特征**：两个矩形区域水平（参见图 17.4A）或垂直（参见图 17.4B）彼此相邻。
- **三矩形特征**：中央矩形区域两侧各有两个其他矩形区域（参见图 17.4C）。这是检查眼睛的理想模型。
- **四矩形特征**：四个矩形区域以网格状排列，如图 17.4D 所示。

<Figure
  src={require("./17_4.jpg")}
  num="17.4"
  desc="Haar 特征示例"
  size={320}
  edge="white"
/>

面部检测操作使用多个 Haar 特征。将所有阴影区域的值相加就很好了，但是在特征重叠的常见情况下会发生什么？再次对这些区域求和的效率并不高。这种情况将在下一节中讨论。

### 创建完整的图像

在上一节中，你了解到 Haar 特征由求和并比较的像素区域组成。没有任何规则规定你必须在一个块中计算整个区域。如果 Haar 特征与另一个 Haar 特征重叠，则将每个特征分解为多个区域并将这些区域求和在一起是有意义的。结果被称为“积分图像”（见图 17.5）。

<Figure
  src={require("./17_5.jpg")}
  num="17.5"
  desc="简单积分图像"
  size={320}
  edge="white"
/>

积分图像可帮助你快速计算图像子区域的总和。积分图像中的每个像素都是其上方和左侧像素的总和。看图中简单的积分图像。有四个像素值：1、5、2 和 4。这些像素用零填充以使算法更清晰。因为 1 是左上角的像素，所以它的值保持不变。它的上方和左侧都有一个零。它旁边的值 5 是它本身与它上面和左边的所有值的总和，使其积分值为 6。2 上面有一个 1，使其积分值为 3。最后，4 位于右下角，这意味着它将是其上方和下方所有内容的总和。

积分图像的公式如下：

<Figure src={require("./17_a.jpg")} size={220} edge="white" />

让我们看看这将如何适用于我们的哈尔地区。作为一个例子，请看图 17.6。长虚线矩形内的区域包含需要求和的整个 Haar 特征。粗黑色矩形内的区域与另一个 Haar 区域重叠。由于你不想再次对另一个特征对该区域进行求和，因此你可以将其分解为自己的块，并保留求和值，以便稍后在重叠的 Haar 特征中使用。特征的其余部分被细分为另外两个矩形以求和。将这三个矩形相加，得到 Haar 特征的值。

<Figure
  src={require("./17_6.jpg")}
  num="17.6"
  desc="积分图像示例"
  size={420}
  edge="white"
/>

求和操作从每个矩形的左上角开始，到特征的右下角坐标结束。要求和的最后一个坐标是该区域中其他像素的复合值。

让我们看看短虚线矩形内的区域。矩形从 `(0, 0)` 开始，到 `(2, 1)` 结束。该特征区域的值为

```
i(0,0) + i(0, 1) + i(1,0) + i(1, 1) + i(2,0) + i(2,1)
```

该和的值将存储在 `(2, 1)` 中。要添加此 Haar 特征的所有值，你最终只添加三个值：

```
i(2,1) + i(0,4) + i(2,4)
```

### AdaBoost 培训

AdaBoost 学习涉及训练神经网络来查看数千张面部图像，以了解哪些特征重要、哪些特征不重要。每个特征本身就是一个 _弱分类器_。一个特征可能代表也可能不代表一张脸。但是，如果你组合许多弱分类器，则可以制作最终的 _强分类器_。这个过程告诉算法要在图像中寻找什么。

### 级联分类器

Haar 特征的一个主要问题是它们可以针对图像内的任何像素区域进行计算。对于任何给定的图像，这可能会产生数以万计的可能的 Haar 特征。无论从图像中提取积分图像的效率如何，计算每一个图像的效率都不够高。这就是 _级联分类器_ 的用武之地。

第二次世界大战期间，一群英国密码破译者负责破解德国恩尼格玛密码机。基本的三转子恩尼格玛机对于六个轮阶中的每一个都有 `26 x 26 x 26 = 17,576` 种可能的转子状态，从而给出 `6 x 17,576 = 105,456` 种机器状态。对于其中的每一个，插接板（连接了 10 对字母）可以处于 150,738,274,937,250 种可能的状态。密码破译者并没有尝试计算每一个状态，因为这将花费比密码重置之前的 24 小时更长的时间。相反，他们通过了解编码到机器中的单词和信息的类型，对如何消除各种状态做出了明智的猜测。他们能够通过明智地排除低概率状态来减少这个数字。

对于计算机科学中的某些问题，验证答案是否正确比解决问题更容易。在某种程度上，这就是千年奖问题 P 与 NP 的基础。对于计算机来说，确认它正在检查的部分没有人脸比确认有人脸要快得多。一旦计算机知道它可以丢弃该区域，它就可以节省可能包含面部的部分的更昂贵的计算工作。

级联分类器在概念上类似于链式选项的想法。当级联确定该区域不包含人脸时，级联可以在级联中的任何点中止。

Viola-Jones 的最大限制是它需要完整的正面直立脸部的完整视图，例如在大头照中看到的那些。它对于个人头像或俯视或侧视的图像无效。

## 概括

机器视觉是计算机科学的一个重要且不断增长的部分。我们所看到的一切都可以简化为数值。这些数值可以由计算机进行处理和量化。通过了解这些数据所传达的内容，我们可以创建描述和提取图像特征的算法。
