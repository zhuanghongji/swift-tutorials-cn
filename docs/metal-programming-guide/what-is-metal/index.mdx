# 什么是 Metal

<ToBePolishedAfterTranslation />

<Wisdom
  words="在这一点上，我们必须抛弃旧模型，并采用新的现实规则。"
  author="弗诺·文奇"
/>

2014 年，Apple 为 iOS 引入了新的低级 GPU 编程框架：Metal。一年后，Metal 登陆 macOS，随后是 watchOS 和 tvOS。苹果设备有两个可以编程来创建应用程序的"大脑"：中央处理单元（CPU）和图形处理单元（GPU）GPU 是一种专用处理器，可以非常快速高效地并行执行浮点数学运算。这些任务在 CPU 上的成本很高，因为它们无法并行完成，因此创建了各种框架和 API，将这些昂贵的任务卸载到最适合执行这些任务的处理器。

浮点数学是图形编程不可或缺的一部分，但这并不是它的唯一应用。非图形 GPU 编程称为通用 GPU (GPGPU) 编程。较旧的图形范例（例如 OpenGL）是在 GPGPU 编程可行之前开发的 OpenGL 对于 iPhone 的前 5 年来说已经足够了，但随着它变得更加强大并且可以完成更多任务，它也在不断发展。

## 图形 API 的历史

三维计算机图形可以追溯到 20 世纪 60 年代和 1970 年代 James Blinn 和 Edwin Catmull 等先驱者的工作为当今的许多创新铺平了道路。但直到 20 世纪 80 年代和 90 年代的家用计算机革命之后，计算机图形才变得无处不在。

在 20 世纪 80 年代，编写跨平台软件非常困难，尤其是游戏。每台计算机和视频游戏系统都有自己专有的硬件和软件驱动程序。每次你想要在新设备上发布软件时，你都必须编写特定于设备的驱动程序、软件和用户界面。这项工作是重复性的，而且感觉基本上没有必要。

1981 年，Silicon Graphics (SGI) 公司成立。它制造高性能 3D 工作站。与所有其它 3D 工作站制造商一样，它拥有自己的专有 3D 图形 API，称为 IRIS GL。它在 20 世纪 80 年代的大部分时间里占据着市场主导地位，但到了 90 年代初，其市场份额已经被侵蚀 1992 年，为了防止市场份额进一步受到侵蚀，它开放了 IRIS GL API 并将其更名为 OpenGL。

直到 1997 年，OpenGL 才成为事实上的 3D 图形 API。视频游戏公司 idSoftware 在首席程序员 John Carmack 的领导下，开发了其最畅销视频游戏 _Doom_ 的后续版本。它被称为 _Quake_ 。每个游戏平台都渴望将《雷神之锤》移植到自己的平台上。卡马克不想为市场上的每种硬件和操作系统编写独特的驱动程序，因此他选择 OpenGL 作为标准。他告诉制造商，如果他们不支持 OpenGL，他们就无法将 _Quake_ 移植到他们的平台上。制造商编译并编写了驱动程序来支持 OpenGL。由于每个制造商都已完成支持 OpenGL 的工作，因此许多游戏开发人员开始专门支持 OpenGL，因为他们知道它可以在每个平台上运行。瞧！一个行业标准诞生了。

2004 年，OpenGL 2.0 发布。这是 OpenGL 的重大进步，因为它引入了 OpenGL 着色语言。这种类似 C 的语言允许程序员为 GPU 编写程序并修改可编程管道的转换和片段着色阶段（见图 1.1）。

<Figure
  src={require("./1_1.jpg")}
  num="1.1"
  desc="应用分子。左边是具有固定功能管道的应用程序。右边是使用着色器增强的版本。"
  edge="black"
/>

当着色器被添加到 OpenGL 时，API 开始变得相当粗糙 OpenGL 最初发布时，GPU 的功能并不是特别强大。他们无法处理太多工作。最初的 OpenGL API 旨在将尽可能多的工作推送给 CPU，因为 GPU 是一个瓶颈。当着色器发布时，这种限制已经发生了巨大的变化 GPU 的功能越来越强大，许多原来执行任务的方式效率低得令人难以置信。随着时间的推移，新的方法被引入以适应这种新的现实，但旧的方法从未从 API 中删除。执行相同任务有多种方法，其中一些方法比其它方法更有效。

2003 年，OpenGL 的精简版本发布：OpenGL ESOpenGL ES 是 OpenGL 的子集。它删除了所有旧的、粗糙的实现，这些实现不再是向 GPU 分配工作的最佳方式。它是为嵌入式设备（例如视频游戏控制台和智能手机）开发的，但任何用 OpenGL ES 编写的程序都可以在使用 OpenGL 的程序上运行，只需对着色器进行一些小的修改 2007 年，OpenGL ES 2.0 发布。该版本包含着色器和可编程管道。

也是在 2007 年，第一代 iPhone 发布。第一个 iOS SDK 中可用的图形框架和 API 极其有限，但 iPhone 确实支持 OpenGL ES。大多数想要在游戏和应用程序中采用复杂图形的开发人员必须在 OpenGL ES 中对所有内容进行编程。许多拥有多年使用 OpenGL 经验的程序员能够在 SDK 出现时为 iPhone 创建复杂的图形。

正处于起步阶段 2010 年，Apple 开始在 iPhone 上支持 OpenGL ES 2.0 以及可编程着色器。

多年来，Apple 为 iPhone 上的图形开发了更高级别的抽象：Sprite Kit、Scene Kit 等。但如果你想直接对 GPU 进行编程，则必须使用 OpenGL ES。你还必须对 GPU 进行图形编程。你无法利用 GPU 进行通用编程，也无法利用 Apple 与其其它框架的紧密硬件/软件集成。

## Metal：在 Apple 平台上制作图形的新方法

今天，我们的口袋里装着超级计算机 iPhone 的计算能力正在接近我们许多笔记本电脑的计算能力。即使拥有所有这些额外的功能，我们仍然受到 OpenGL API 的速率限制。由于 OpenGL 必须适应 GPU 和 CPU 的所有组合和变化，因此它永远无法充分利用 Apple 为其所有产品提供的深度集成 Apple 确切地知道将使用哪个芯片进行 GPU 编程，并且可以优化框架以专门、直接地适应该芯片的特性。

除了现在可以通过控制整个制造链实现深度集成之外，OpenGL 还存在一些结构性问题，导致其无法发挥应有的效率。有许多昂贵的操作被安排在每个不必要的绘制调用上发生。通过更改操作顺序并将昂贵的工作移至绘制调用之外，Metal 释放了更多处理器带宽。通过让程序员完全控制他们想要如何安排 GPU 的工作，可以进一步释放带宽。

### 平衡 CPU 和 GPU 之间的工作

CPU 和 GPU 是偏置工作的 CPU 为 GPU 准备命令，然后将它们发送给 GPU。当 GPU 处理收到的命令时，CPU 正在准备下一批命令。在图形编程中，你有责任平衡 CPU 和 GPU 之间的工作负载。将工作从 CPU 批处理并发送到 GPU 的时间成本很高。发送给 GPU 的工作越多，花费的时间就越多。在传统的 OpenGL 应用程序中，很多时候这种偏移并不是完美平衡的。通常，CPU 无法向 GPU 发送足够的工作以使其在整个帧中保持忙碌，因此 GPU 处于空闲状态，如图 1.2 所示 Metal 提高了这种偏移的效率，以便 GPU 可以充分利用。效率提高的部分原因是无需在 CPU 和 GPU 之间复制内存。

<Figure
  src={require("./1_2.jpg")}
  num="1.2"
  desc="在较旧的图形 API 中，CPU 无法批处理足够的工作以保持 GPU 得到充分利用。"
  edge="white"
/>

### 复制内存

OpenGL 之所以如此设置，是因为直到最近，CPU 和 GPU 始终位于单独的芯片上。它要求将数据从一个芯片复制到另一芯片，这需要昂贵的线程锁来确保不会发生竞争条件并覆盖数据。

在 iPhone 的每一次迭代中，CPU 和 GPU 都占用相同的芯片。这样就不需要来回复制数据，从而消除了先前计算机体系结构中遗留下来的昂贵操作（见图 1.3）CPU 只是授予 GPU 访问权限以直接修改数据。从 A7 芯片开始，苹果通过支持 Metal 充分利用了这种设计。

<Figure
  src={require("./1_3.jpg")}
  num="1.3"
  desc="通过消除复制内存的需要，可以消除昂贵的批量复制命令。"
  edge="white"
/>

### 直接控制命令缓冲区

命令缓冲区是 Metal 应用程序的中央控制对象 Metal 与 OpenGL 不同，因为它让程序员可以访问此控件，而不是以简化的名义将其抽象出来。将命令缓冲区暴露给程序员可以在何时以及如何执行渲染缓冲区方面提供更大的灵活性。在 OpenGL 中，由 OpenGL 驱动程序（而不是开发人员）决定工作顺序。通过向开发人员公开缓冲区的复杂性并允许他们按照自己喜欢的顺序对工作进行排队，Metal 提供了对应用程序性能的更多控制。可以创建多个线程，并且可以延迟缓冲区执行。

### 预编译着色器

在 OpenGL 中，着色器是在运行时编译的。编译着色器的成本很高。在 Metal 出现之前，这项工作必须在每次绘制调用时完成。在加载时编译这些着色器没有多大意义。这项工作可以从加载时间移至应用程序构建时间。预编译的着色器可以存储在库中，以便在运行时引用它们，从而将耗时且昂贵的工作转移到不影响用户体验的地方。

### 预验证状态

在其它图形 API 中，在每次绘制调用时，应用程序都必须检查以确保 API 上的状态有效，以避免向 GPU 发送错误命令。应用程序中的状态会发生变化，但不会在每次绘制调用时发生变化。作为开发人员，你可以在命令编码器中对这些状态更改进行编码。命令编码器被提交到命令缓冲区，并且仅当状态实际改变时才会发生昂贵的状态验证。

Apple 工程师使 Metal API 尽可能精简。精简设计意味着在批处理工作并将工作从 CPU 发送到 GPU 时需要运行的工作更少。它消除了由 GPU 默默完成的不必要的工作，因为 GPU 的工作被从程序员手中抽象出来，使他们的工作变得更容易。使这项工作的发送成本更低意味着程序员不再受 CPU 的速率限制。他们可以充分利用 GPU 的潜力。

## Metal 背景： Metal 如何补充和支持其它 Metal

### 平台框架

Metal 框架是一项非凡的成就，但它并不独立存在。它是庞大的 Cocoa 框架生态系统的一部分。它扮演着重要角色，但不是独唱演员。它集成到许多其它框架中，并且依赖于其它框架。

多个框架已更新以利用 Metal，包括 SceneKit 和 SpriteKit。如果你想做一些不高度专业化的事情，你可以通过使用这些框架之一来利用 Metal。它们还可以轻松地与 Metal 集成。如果你想为 SceneKit 项目编写自定义着色器，可以轻松地使用 Metal 来获取所需的部分，同时仍然利用 SceneKit 提供的更高级别的抽象。

Metal 遵循数据守恒定律。它不会创建或销毁数据；它只是修改它。因此，Metal 需要一个数据源 Cocoa 中专门设置为充当数据源的一个框架是模型 I/O 框架。模型 I/O 提供了一种从 3D 建模程序引入顶点数据的简单方法。它被设计为与 Metal 紧密集成。

你可以让 Model I/O 完成解析数据文件和加载顶点缓冲区的所有繁重工作，以便你可以专注于要对数据执行的操作，而不是如何将其放入应用程序中。

## 概括

Apple 革命性的全新 GPU 编程框架解决了传统图形编程 API 的许多长期存在的问题。通过利用硬件和软件的紧密集成，Apple 充分利用了 GPU 的所有功能。通过将昂贵的任务移出绘制调用之外，Apple 可以降低向 GPU 发送命令的成本，从而释放更多的 CPU 时间来改进应用程序的其它方面 Metal 还被设计为与其它 Apple 框架完美集成，让你比以往更轻松地利用这些框架来完成常见任务，而无需转向 Metal。
