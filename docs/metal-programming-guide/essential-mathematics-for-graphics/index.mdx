# 图形基础数学

<ToBePolishedAfterTranslation />

<Wisdom
  words="诗人和数学家之间的区别在于，诗人试图让他的头脑进入天堂，而数学家试图让天堂进入他的头脑。"
  author="G.K. Chesterton"
/>

在图形编程中，你需要了解两个部分：编程框架以及它能够解决什么问题。图形的语言是数学，这是我们描述周围世界的最纯粹的语言。我们看到的一切和移动的一切都可以用数学来表达，并且方程可以很容易地用代码表达。本章涵盖了一些重要的数学概念，这些概念使框架能够将毫无生气的代码转变为生动、详细的图形。

## 数学语言

算法是计算或其它解决问题的操作中要遵循的过程或一组规则。算法的核心是它所描述的想法或过程。这种描述可以用多种"语言"来表达——例如英语、JavaScript 或线性代数。在头脑中清晰地表达如何解决问题以及流程的作用的能力是一项宝贵的技能，它将在你作为图形程序员的旅程中为你提供帮助。

以数学方式表达事物的优点之一是数学算法与平台无关。截至撰写本文时，还没有大量关于 Metal 编程的书籍，但围绕图形数学的概念已经存在了数百年。能够"说"这种语言可以让你使用这些资源来实现令人难以置信的效果 - 你不再局限于用 Metal 语言编写的材料。

图形数学是一个广阔的话题。它包括线性代数、向量微积分和统计学的各个方面。这些信息可以而且确实可以写满几本书。本章对你应该熟悉的概念以及它们如何适应此过程进行了高级概述。有许多关于着色器效果的精彩资源，但其中许多资源要么是特定于平台的，要么以数学方式表达他们的想法。对这些概念有基本的了解后，你就可以解码这些资源，即使它们可能适用于不再存在的软件。

## 坐标空间并在其中移动

图形编程归结为弄清楚如何表达对象如何在空间中出现和移动。在开始在空间中移动对象之前，你需要确定它的位置以及它的移动方式 - 你需要一个坐标系。坐标系需要

- 原点
- 一致的测量单位
- 确定正负方向的约定

我们大多数人记得的最早的坐标系是笛卡尔坐标系。二维笛卡尔系统由两条垂直线表示，一条水平线（x 轴）和一条垂直线（y 轴）。每条线都包含以相同长度单位测量的等距刻度（当你学习这个系统时，你可能使用方格纸，每个方块代表相等的长度）x 轴和 y 轴相交的地方是*原点*。原点右侧水平线上和原点上方垂直线上的每个刻度均被视为正值。原点左侧的水平线上和原点下方的垂直线上的每个刻度都被视为负值。在 3D 笛卡尔坐标系中，添加了第三条线，即 z 轴，垂直于 x 轴和 y 轴（见图 4.1）。向上和向右移动的物体沿正方向移动，向下和向左移动的物体沿负方向移动。

<Figure
  src={require("./4_1.jpg")}
  num="4.1"
  desc="Metal 的 3D 坐标空间"
  size={320}
  edge="white"
/>

尽管这个系统很熟悉，但它并不是唯一的坐标系。例如，向上的轴可以是 z 轴而不是 y 轴。或者 y 轴向上可能是负值而不是正值。坐标系的另一个重要方面（在本章后面特别适用）是了解你正在处理的是左手坐标系还是右手坐标系。这与相对于旋转轴的正方向和负方向有关。如果坐标系是右手坐标系，则正旋转轴逆时针移动。如果坐标系是左手坐标系，则正旋转轴是顺时针方向。

在开始使用坐标系之前，了解管理坐标系的规则非常重要 Metal 实际上有两个坐标系。一种适用于 3D 世界空间，另一种适用于光栅化 2D 投影空间。在 Metal 的 3D 坐标系中，x 轴和 y 轴都从 `-1` 到 `1`，使这些坐标有两个单位长 z 轴不同，仅从 `0` 到 `1`。Metal 的 2D 坐标系与 Core Graphics 使用的相同，但与 OpenGL 坐标系相反。它的原点位于左上角

投影空间 x 值是对象出现的跨空间距离，y 值是对象出现的空间向下的距离。如果你不熟悉将要使用的坐标系，你将无法准确描述你希望对象在空间中的显示方式。

## 点、向量和向量运算

我们介绍的下一个概念是*point*。点是空间中的一个坐标。我们以一个点为例：`(3, 4, 0)`。第一个数字是点的 _x_ 坐标，第二个数字是 _y_ 坐标，第三个数字是 _z_ 坐标。图 4.2 中所示的点 B 描述了距原点向右 3 个单位、向上 4 个单位的位置。

<Figure
  src={require("./4_2.jpg")}
  num="4.2"
  desc="A 点原点与 B 点另一个位置之间的向量"
  size={320}
  edge="white"
/>

向量的表达方式与点类似，但有所不同。矢量被定义为具有大小和方向。让我们采用图 4.2 中的上一个点，但将其更改为向量：`(3, 4, 0)`。虽然表达方式还是一样，但还是有区别的 `(3, 4, 0)` 不是描述空间中的特定点，而是描述一点与另一点之间的运动。为此，你可以使用毕达哥拉斯定理。该向量中的第一个点距离向量中的第二个点有 5 个单位，因为三的平方加四的平方的平方根是四。本章稍后将对此进行更详细的介绍。因为平方根只能是正数，因为它是两个平方数的相加，所以向量沿正方向移动三个单位以上四个单位。该向量可以源自任何地方；没关系。它所描述的只是从一点到另一点的运动。

向量和点都包含在 `float4` 向量类型中。乍一看，这似乎没有意义，因为点和向量只有三个坐标。那么第四个组件是做什么用的呢？第四个组件区分 `float4` 是点还是向量。点的值为 `1`，向量的值为 `0`，作为 `float4` 中的最后一个值。

可以对点和向量执行多种操作。可以减去点来创建向量。积分不能相加。向量可以乘以标量来放大或缩小。在上一段中，你了解到点的最终值为 `1`。对点和向量进行的任何合法运算都会导致最终坐标值等于 `1` 或 `0`。在本概述中，我们重点关注广泛使用的两种特殊向量运算在计算机图形学中：点积和叉积。

两个向量的点积是通过将每个向量的 x 分量相乘并将其与每个向量的 y 分量的乘积相加得出的。

<Figure src={require("./4_a.jpg")} size={420} edge="white" />

点积还给出两个长度均为 `1`。这个简单的解释并没有解释你可以使用点积做什么，也没有解释为什么它与你作为图形程序员的旅程相关。从本质上讲，点积是一种衡量一个向量对另一个向量影响的方法。

矢量效果的一个很好的例子是视频游戏《马里奥赛车》。在《马里奥赛车》中，赛道上的某些区域可以让你加速。如果你的购物车没有移动，则速度提升不会起到任何作用，因为点积增强了你已经在做的事情。速度提升仅有助于增加前进动力，因此如果你主要是横向移动，那么它不会对你有太大帮助。

假设你向前的速度提高了两倍，但你并没有向前移动。你的前向向量是 `(0, 0)`。速度提升向量为 `(0, 2)`。这些向量的点积为 `(0 * 0) + (0 * 2)`，仍然为零。但是，如果你向前移动一个单位，但横向移动三个单位，则点积对你的横向移动没有影响。在这种情况下，点积将为 `(3 * 0) + (1 * 2)`，等于 `2`。无论你横向移动的速度有多快，它都不会影响最终结果，因为速度提升的目标只是一根运动轴。

图形编程中的点积除其它外还用于确定光如何与对象交互。对于照明，它会找到表面法线与光线来自的方向所形成的角度的余弦。当你阅读本章时，会对此进行进一步解释。

叉积与点积相关，但又有所不同。点积涉及同一维度内相互垂直的大小之间的相似程度。它将 x 值与 x 值进行比较。它不关心 y 值或 z 值是多少。叉积确实如此。叉积用于求两个向量之间的旋转轴，如图 4.3 所示。

<Figure
  src={require("./4_3.jpg")}
  num="4.3"
  desc="如何计算叉积"
  size={420}
  edge="white"
/>

## 归一化和单位向量

当你处理百分比时，许多与图形相关的数学会更容易完成。如果你将 iPhone 屏幕视为长 1 个单位、宽 1 个单位，屏幕中心为 `(0.5, 0.5)`，则你不必考虑屏幕的像素分辨率是多少，或者你使用的是 iPhone 的哪一版本。开始了。这种哲学适用于图形编程中的许多其它方程，这就是为什么你应该了解的一个重要数学概念是向量归一化过程。

许多图形编程都假设你正在使用百分比并且值不会大于 1。如果你有一个单位值为 3、4 和 5 的直角三角形，为了对此执行算法三角形，你需要确定这些值如何按比例缩放。斜边的值为 1，而其它两条边是该斜边的一定百分比。要找到该比率，请将每条边除以斜边的值。因此，三角形不再是 `(3, 4, 5)`，而是标准化为 `(3/5, 4/5, 和 1)`。

矢量归一化对于确定方向很有用。例如，点积的一种常见用途是计算光线与表面法线之间的角度的余弦，如图 4.4 所示。仅在向量归一化后才进行此计算。

要标准化向量，请对向量的分量执行毕达哥拉斯定理。也就是说，对每个分量求平方，将它们加在一起，然后取该数字的平方根。在我们的 `(3, 4, 0)` 向量中，`3^2 = 9`、`4^2 = 16`、`0^2 = 0`，因此 `9 + 16 + 0 = 25`。25 的平方根是 5，即向量的长度。要获得标准化坐标，请将每个分量除以长度。这告诉你每个分量占整个向量的百分比。

<Figure
  src={require("./4_4.jpg")}
  num="4.4"
  desc="归一化向量"
  size={420}
  edge="white"
/>

标准化向量不会改变向量的形状或角度。它只是按比例放大或缩小矢量。想象一个 45-45-90 度的直角三角形。无论如何，有关该三角形的某些规则都适用。无论长度是 10 个单位还是 42 个单位，三条边中的两条始终具有相同的长度。将斜边设为一个单位，将其它边设为该单位的百分比，可以使斜边更容易进行数学处理。许多与坐标系相关的单位都是任意的。重要的是要确保三角形的边和角的比例一致。

## 勾股定理

前面许多涉及点积和归一化的部分都依赖于正交性。正交性涉及两条彼此成直角的直线的关系。如果你有一组正交或彼此垂直的线，则有一个强大的方程可以让你计算图形编程中的许多有用的度量：毕达哥拉斯定理。

毕达哥拉斯定理使你能够找到正交方向之间的最短距离，如图 4.5 所示。这实际上与直角三角形无关；而是关于直角三角形。这是关于比较以直角移动的"事物"。当我们查看点积时，我们正在研究组合两个向量将如何影响它们在 x 和 y 方向上的增长。

<Figure
  src={require("./4_5.jpg")}
  num="4.5"
  desc="毕达哥拉斯定理"
  size={420}
  edge="white"
/>

即使我们的向量而不是三角形本身，我们也可以将它们视为三角形，以便能够使用毕达哥拉斯定理。此外，我们用于网格的形状是三角形，这确实符合毕达哥拉斯定理。该定理是大多数向量运算的基础，你将使用这些运算来确定向量如何相互影响。重要的是要明白，这个看似简单的公式是释放 3D 图形大部分功能的关键。

## 正弦、余弦和正切

高中三角课上的另一个需要深入记忆的概念是三个三角形运算：正弦、余弦和正切。如果你参加 SAT 考试后还没有思考过这些概念，那么你可能对它们有点模糊。图 4.6 说明了三角形运算的示例。在本节中，我们将讨论它们的含义以及它们如何帮助你在图形编程中完成巧妙的事情。

<Figure
  src={require("./4_6.jpg")}
  num="4.6"
  desc="正弦、余弦和正切运算"
  size={720}
  edge="white"
/>

每个不是等边三角形或不等边三角形的三角形都有一条边比其它边长。这条边是斜边，这很重要，因为图形编程中执行的许多操作都是基于涉及斜边的三角函数。在大多数矢量运算中，你将假设矢量是三角形的斜边。

助记符可以帮助你记住如何求正弦、余弦和正切：SOH CAH TOA。它翻译为

- **正弦**：对边除以斜边
- **余弦**：相邻除以斜边
- **正切**：对边除以相邻

要获得标准化坐标，请将每个分量除以长度。回想一下如何标准化向量坐标的描述：将每条边除以斜边的长度，结果斜边等于 `1`。一个额外的好处是，此操作还可以计算出以下值的正弦和余弦：三角形。当你阅读"变换：缩放、平移、旋转、投影"部分时，这些知识将特别有用。

## 矩阵和矩阵运算

矩阵是看起来很吓人的结构，但一旦你理解了它们，它们就会非常强大。它们在 3D 图形编程中广泛使用并且是不可避免的。因此，让我们深入研究矩阵并利用它们的用处。

在 3D 图形编程中要处理的主要矩阵类型是 4x4 矩阵。该矩阵的一种用途称为 _变换矩阵_。变换矩阵用于将点和向量从一种形状和空间变换到另一种形状和空间。有一些相关的活动部件

此过程将在本节中详细介绍。

使用矩阵的基础在于点积，本章前面已介绍过。点积涉及计算相似坐标空间的权重。想想电梯。电梯可以上下移动，但无论电梯运行多快多高，都无关紧要，因为它不会左右移动。电梯的速度和高度永远不会影响其前后或左右移动，因为电梯的速度和高度被限制在 y 轴上，并且永远不会渗透到 x 轴或 z 轴上。矩阵在坐标不受其它坐标空间中发生的变化影响的地方设置为空值。考虑到这一点，我们来谈谈这如何应用于 3D 图形编程。

### 恒等矩阵

矩阵的 "Hello, World" 是 _单位矩阵_。单位矩阵的设置是为了如果你在坐标上与单位矩阵执行点积，你将得到相同的坐标。要了解矩阵如何影响向量，重要的是要查看一个没有副作用的示例。这样你就可以看到空值如何影响矩阵以及需要在哪里添加值以便仅更改你想要更改的内容。这意味着单位矩阵从左上角坐标到右下角坐标有一条 1s 的对角线。其它都是 0。

```cpp
[
 1 0 0 0
 0 1 0 0
 0 0 1 0
 0 0 0 1
]
```

这是你的默认起点，因为它不会改变或影响任何内容。为什么不尝试一下我们的 `(3, 4, 0)` 坐标呢？

```cpp
[
 3
 4
 0
 1
]
```

如果使用单位矩阵对这一点执行矩阵运算，你将得到以下结果：

```cpp
C1 = (3 * 1) + (4 * 0) + (0 * 0) + (1 * 0) = 3
C2 = (3 * 0) + (4 * 1) + (0 * 0) + (1 * 0) = 4
C3 = (3 * 0) + (4 * 0) + (0 * 1) + (1 * 0) = 0
C4 = (3 * 0) + (4 * 0) + (0 * 0) + (1 * 1) = 1
```

你将修改单位矩阵来执行某些任务，但重要的是要知道需要做什么才能得到与输入相同的结果，这样你就可以隔离每个坐标上发生的副作用。

## 变换：缩放、平移、旋转、投影

现在你已经对矩阵运算的工作原理有了基本的了解，现在是时候解释如何在图形编程环境中使用它们了。图形编程的很大一部分——也是它如此迷人和强大的原因之一——是它实现变革的能力。你可以更改场景中对象的大小、位置、旋转等。这就是你获得互动的方式

计算机图形，而不仅仅是挂在墙上的漂亮图片。所有这些操作都称为 _transformations_ ，并且它们都可以表示为矩阵。

### 尺度矩阵

现在你已经掌握了如何设置矩阵，让我们继续实际更改一些值并查看矩阵的更改。我们讨论的第一个矩阵是尺度矩阵。尺度矩阵与单位矩阵没有太大区别。

尺度矩阵具有与单位矩阵相同的零，但它不一定继续使用对角线上的零。你正在尝试决定如何缩放坐标，并且不希望默认缩放值为 1。这是缩放矩阵：

```cpp
[
 Sx 0  0  0
 0  Sy 0  0
 0  0  Sz 0
 0  0  0  1
]
```

对于 Sx、Sy 和 Sz，你可以确定要缩放该坐标的程度，并将该值输入到矩阵中。其它一切都没有改变或受到影响。这是除了单位矩阵之外最容易处理的矩阵，因为从某种意义上说，单位矩阵可以是尺度矩阵。它的标度只有 1。

### 翻译矩阵

我们讨论的下一个矩阵是平移矩阵。平移矩阵稍微调整了单位矩阵。我们已经确定单位矩阵返回与你开始时相同的坐标。平移矩阵更进一步，将平移值应用于坐标。

平移矩阵看起来与单位矩阵相同，但最后一列有点不同。最后一列对 _x_ 、 _y_ 和 _z_ 坐标应用变化量：

```cpp
[
 1 0 0 Tx
 0 1 0 Ty
 0 0 1 Tz
 0 0 0 1
]
```

让我们回顾一下我们的 `(3, 4, 0)` 坐标。该坐标可写为：

```cpp
[
 3
 4
 0
 1
]
```

假设你要将 x 值调整 3。你不希望坐标中的其它任何内容发生变化；你只希望 _x_ 值增加 3。平移矩阵如下所示：

```cpp
[
 1 0 0 3
 0 1 0 0
 0 0 1 0
 0 0 0 1
]
```

矩阵的底部三行与单位矩阵相同，所以现在不用担心它们。只需看看这个平移如何影响第一个坐标：

```cpp
(3 * 1) + (4 * 0) + (0 * 0) + (1 * 3) = 6
```

如果你尝试将平移应用于向量会发生什么？没有什么。矢量不代表空间中的特定点，因此不会受到影响。让我们将测试坐标设为向量：

```cpp
[
 3
 4
 0
 0
]
```

现在让我们对其进行疯狂的翻译：

```cpp
[
 1 0 0 42
 0 1 0 108
 0 0 1 23
 0 0 0 1
]
C1 = (3 * 1) + (4 * 0) + (0 * 0) + (42 * 0) = 3
C2 = (3 * 0) + (4 * 1) + (0 * 0) + (108 * 0) = 4
C3 = (3 * 0) + (4 * 0) + (0 * 0) + (23 * 0) = 0
C4 = (3 * 0) + (4 * 0) + (0 * 0) + (0 * 0) = 0
```

因为向量中的最后一个值是 `0`，所以无论你尝试如何彻底地平移向量，它都不会改变。这一切都很好，但我们为什么要这样做呢？理解平移矩阵可以让我们做什么？

### 旋转矩阵

运动是交互式 3D 图形的重要组成部分。有时，运动是不受约束的，就像球一样，可以向各个方向移动，但有许多运动子集是围绕旋转旋转的。如果你要制作门打开的动画，则当门围绕铰链所在的边缘旋转时，该操作的可用运动范围有限。该运动可以通过矩阵运算来计算。

如果你阅读"正弦、余弦和正切"部分，你就会了解到使用正弦和余弦来确定三角形的角度。如果你将向量的初始位置视为三角形的一侧，并将所需的最终位置视为另一侧，则可以利用三角形运算来找出如何描述矩阵中向量的旋转。

旋转矩阵的示例如下所示：

```cpp
[
 1 0    0     0
 0 cosθ -sinθ 0
 0 sinθ cosθ  0
 0 0    0     1
]
```

该矩阵描述了绕 x 轴的旋转角度。因为 x 轴充当门上的铰链，所以它不会改变。你选择要旋转矢量的角度并

新的 _y_ 和 _z_ 坐标是通过应用旋转角度的正弦或余弦来计算的。

### 投影矩阵

我们讨论的最后一个矩阵是你需要理解的一个重要矩阵，那就是投影矩阵。在图形编程中，你使用两个空间：相机空间和世界空间。世界空间包含场景中的每个对象。相机空间决定了视野内有多少个物体。场景中的某些区域在任何给定时刻并不总是可见，这是可能且常见的。想想任何第一人称射击游戏。如果你的角色沿着走廊移动，则你的角色经过的区域将不再位于你的视野中，并且不应再进行渲染。

投影矩阵确定相机空间，即场景中的可见区域，以便渲染器知道仅检查可见位置的对象。它还可以通过确定对象是否部分超出屏幕并需要重新三角化来帮助确定剪切区域。你正在从考虑与模型起源相关的所有事物转变为考虑与世界空间起源相关的模型。

### 级联

到目前为止，我们一直在讨论将矩阵应用于坐标。但是，是否可以将一个矩阵应用于另一个矩阵？绝对地。将两个矩阵相乘的过程称为"串联"。串联不仅仅限于两个矩阵。事实上，在图形编程中，你将链接许多矩阵运算，并且这些运算可以连接成一个矩阵。

要将一个矩阵应用于另一个矩阵，请从要相乘的两个矩阵中获取相应行和列的点积，如图 4.7 所示。例如，如果你想在新矩阵的第一行中查找第二个值，则需要计算第一个矩阵的第一行和第二个矩阵的第二列的点积。

<Figure
  src={require("./4_7.jpg")}
  num="4.7"
  desc="矩阵串联是如何计算的"
  edge="white"
/>

如果你有两个以上的矩阵，你仍然可以执行此操作。前两个矩阵的点积创建一个可应用于下一个矩阵的临时矩阵，依该类推。然后可以应用这些矩阵来变换坐标。需要注意的是，矩阵乘法通常是从右到左进行的，而不是从左到右进行的，这就是将向量视为列矩阵时发生的情况。

## 概括

用于在屏幕上创建图像的所有操作的基础都是以数学方式表达的。本章复习了三角学、线性代数和向量微积分。你了解了如何使用毕达哥拉斯定理和归一化向量来计算旋转角度。你了解到三角测量是大多数图形操作的核心，你所做的一切都依赖于对这些基础知识的理解。
