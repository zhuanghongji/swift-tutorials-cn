## 3.2 矩阵运算符

算术运算符加 (+)、减 (–) 对矩阵进行运算。两个矩阵必须具有相同的行数和列数。该操作按分量完成，产生相同大小的矩阵。算术运算符乘法 (\*) 作用于：

- 标量和矩阵 - 矩阵和标量 - 向量和矩阵 - 矩阵和向量 - 矩阵和矩阵

``2023 - 06 - 02 |版权所有 © 2023 苹果公司 |版权所有。 ````

如果一个操作数是标量，则将该标量值乘以矩阵的每个分量，从而得到相同大小的矩阵。右向量操作数被视为列向量，左向量操作数被视为行向量。对于向量到矩阵、矩阵到向量和矩阵到矩阵乘法，左操作数的列数需要等于右操作数的行数。乘法运算执行线性代数乘法，生成一个向量或矩阵，其行数与左操作数相同，列数与右操作数相同。

以下示例假定这些向量、矩阵和标量变量已初始化。下面描述的向量到矩阵、矩阵到向量和矩阵到矩阵乘法运算的部分和的顺序是未定义的。

浮点 3 v；

浮点数 3x3 米，n；

浮动 a = 3.0f；

矩阵与标量的乘法：

float3x3 m1 = m \* a;

相当于：

m1[0][0] = m[0][0] \* a;

m1[0][1] = m[0][1] \* a;

m1[0][2] = m[0][2] \* a;

m1[1][0] = m[1][0] \* a;

m1[1][1] = m[1][1] \* a;

m1[1][2] = m[1][2] \* a;

m1[2][0] = m[2][0] \* a;

m1[2][1] = m[2][1] \* a;

m1[2][2] = m[2][2] \* a;

向量到矩阵的乘法：

float3 u = v \* m;

相当于：

u.x = 点(v, m[0]);

u.y = 点(v, m[1]);

u.z = 点(v, m[2]);

矩阵到向量的乘法：

float3 u = m \* v;

``2023 - 06 - 02 |版权所有 © 2023 苹果公司 |版权所有。 ````

相当于：

u.x = m[0].x _ v.x + m[1].x _ v.y + m[2].x \* v.z;

u.y = m[0].y _ v.x + m[1].y _ v.y + m[2].y \* v.z;

u.z = m[0].z _ v.x + m[1].z _ v.y + m[2].z \* v.z;

矩阵到矩阵的乘法：

float3x3 r = m \* n; // m, n 是 float3x3

相当于：

r[0].x = m[0].x _ n[0].x + m[1].x _ n[0].y + m[2].x \* n[0].z;

r[0].y = m[0].y _ n[0].x + m[1].y _ n[0].y + m[2].y \* n[0].z;

r[0].z = m[0].z _ n[0].x + m[1].z _ n[0].y + m[2].z \* n[0].z;

r[1].x = m[0].x _ n[1].x + m[1].x _ n[1].y + m[2].x \* n[1].z;

r[1].y = m[0].y _ n[1].x + m[1].y _ n[1].y + m[2].y \* n[1].z;

r[1].z = m[0].z _ n[1].x + m[1].z _ n[1].y + m[2].z \* n[1].z;

r[2].x = m[0].x _ n[2].x + m[1].x _ n[2].y + m[2].x \* n[2].z;

r[2].y = m[0].y _ n[2].x + m[1].y _ n[2].y + m[2].y \* n[2].z;

r[2].x = m[0].z _ n[2].x + m[1].z _ n[2].y + m[2].z \* n[2].z;

``2023 - 06 - 02 |版权所有 © 2023 苹果公司 |版权所有。 ````
