# 纹理寻址和转换规则

<OrigninalPDF title="7.7 Texture Addressing and Conversion Rules" />

指定给 sample、sample_compare、gather、gather_compare、read 和 write 函数的纹理坐标不能是 INF 或 NaN。另外，对于纹理读取和写入函数，纹理坐标必须引用纹理内部的区域。如果纹理坐标超出纹理边界，则读写函数行为未定义。

以下各节讨论在图形或内核函数中读取和写入纹理时转换规则的应用。执行多重采样解析操作时，这些转换规则不适用。

## 7.7.1 归一化整数像素数据类型的转换规则

本节讨论将标准化整数像素数据类型转换为浮点值，反之亦然。

## 7.7.1.1 将标准化整数像素数据类型转换为浮点值

对于具有 8、10 或 16 位归一化无符号整数像素值的纹理，纹理采样和读取函数将像素值从 8 或 16 位无符号整数转换为归一化单精度或半精度浮点数- [0.0 ... 1.0] 范围内的点值。

对于具有 8 位或 16 位标准化有符号整数像素值的纹理，纹理采样和读取函数将像素值从 8 位或 16 位有符号整数转换为标准化单精度或半精度浮点值范围 [-1.0 ... 1.0]。

这些转换按照表 7 第二列中列出的方式执行。6. 转换规则的精度保证 `<= 1.5 ulp`，“极端情况”列中描述的情况除外。

## 表 7.6。转换为标准化浮点值

`从转换规则转换为标准化浮点数`

`极端情况`

`1 位标准化无符号整数`

`float(c) 0 必须转换为 0.0 1 必须转换为 1.0`

`2 位标准化无符号整数`

`float(c) / 3.0 0 必须转换为 0.0 3 必须转换为 1.0`

`4 位标准化无符号整数`

`float(c) / 15.0 0 必须转换为 0.0 15 必须转换为 1.0`

`5 位标准化无符号整数`

`float(c) / 31.0 0 必须转换为 0.0 31 必须转换为 1.0`

`6 位标准化无符号整数`

`float(c) / 63.0 0 必须转换为 0.0 63 必须转换为 1.0`

`8 位标准化无符号整数`

`float(c) / 255.0 0 必须转换为 0.0 255 必须转换为 1.0`

`10 位标准化无符号整数`

`float(c) / 1023.0 0 必须转换为 0.0 1023 必须转换为 1.0`

`16 位标准化无符号整数`

`float(c) / 65535.0 0 必须转换为 0.0 65535 必须转换为 1.0`

`8 位标准化有符号整数`

`` 最大（-1.0，浮点（c）/127.0）````

- 128 和 - 127 必须转换为 - 1.0 0 必须转换为 0.0 127 必须转换为 1.0

`16 位标准化有符号整数`

` 最大（-1.0，浮点数（c）/32767.0）`

- 32768 和 - 32767 必须转换为 - 1.0 0 必须转换为 0.0 32767 必须转换为 1.0

## 7.7.1.2 将浮点值转换为标准化整数像素数据类型

对于具有 8、10 或 16 位归一化无符号整数像素值的纹理，纹理写入函数会将单精度或半精度浮点像素值转换为 8 或 16 位无符号整数。

对于具有 8 或 16 位标准化有符号整数像素值的纹理，纹理写入函数会将单精度或半精度浮点像素值转换为 8 或 16 位有符号整数。

NaN 值转换为零。

从浮点值到标准化整数值的转换按照表 7. 7. 中列出的方式执行。

## 表 7.7。从浮点到标准化整数值的转换

`转换为标准化整数的转换规则`

`1 位标准化无符号整数`

`x = min(max(f, 0.0), 1.0) i0:0 = intRTNE(x)`

`2 位标准化无符号整数`

`x = min(max(f * 3.0, 0.0), 3.0) i1:0 = intRTNE(x)`

`4 位标准化无符号整数`

`x = min(max(f * 15.0, 0.0), 15.0) i3:0 = intRTNE(x)`

`5 位标准化无符号整数`

`x = min(max(f * 31.0, 0.0), 31.0) i4:0 = intRTNE(x)`

`6 位标准化无符号整数`

`x = min(max(f * 63.0, 0.0), 63.0) i5:0 = intRTNE(x)`

`8 位标准化无符号整数`

`x = min(max(f * 255.0, 0.0), 255.0) i7:0 = intRTNE(x)`

`10 位标准化无符号整数`

`x = min(max(f * 1023.0, 0.0), 1023.0) i9:0 = intRTNE(x)`

`16 位标准化无符号整数`

`结果 = min(max(f * 65535.0, 0.0), 65535.0) i15:0 = intRTNE(x)`

`8 位标准化有符号整数`

`结果 = min(max(f * 127.0, - 127.0), 127.0) i7:0 = intRTNE(x)`

`16 位标准化有符号整数`

`结果 = min(max(f * 32767.0, - 32767.0),32767.0) i15:0 = intRTNE(x)`

在 Metal 2 中，所有与非规范数据类型之间的转换都应正确舍入。

## 7.7.2 半精度浮点像素数据类型的转换规则

对于具有半精度浮点像素颜色值的纹理，从半精度到浮点的转换是无损的。使用舍入方式将尾数从浮点转换为半舍入到偶数舍入模式。将浮点数转换为 half 时可能生成的 half 数据类型的非规范化数字可能不会刷新为零。浮点 NaN 可以转换为适当的 NaN 或在 half 类型中刷新为零。必须将浮点 INF 转换为 half 类型中的适当 INF。

## 7.7.3 单精度浮点像素数据类型的转换规则

以下规则适用于读取和写入具有单精度浮点像素颜色值的纹理：

- NaN 可以转换为 NaN 值或刷新为零。- 必须保留 INF。- 非规范化的数字可能会被刷新为零。- 必须保留所有其他值。

## 7.7.4 10 位和 11 位浮点像素数据类型的转换规则

浮点格式使用 5 位指数，对于 10 位浮点类型使用 5 位尾数，对于 11 位浮点类型使用 6 位尾数，并为这两种类型提供附加隐藏位。没有符号位。10 位和 11 位浮点类型保留非正规数。

这些浮点格式使用以下规则：

- 如果指数和尾数均为 0，则浮点值为 0.0。- 如果指数为 31 并且尾数为“= 0，则生成的浮点值为 NaN。- 如果指数为 31 并且尾数为 0，则生成的浮点值为正无穷大。- 如果 0 < = 指数 <= 31，浮点值为 2 ^(指数 - 15) \* (1 + 尾数/N). - 如果指数为 0，尾数为“= 0，则浮点值为 a 非规格化数为 2 ^ (指数 - 14) \* (尾数 / N)。如果尾数为 5 位，则 N 为 32；如果尾数为 6 位，则 N 为 64。

将 10 位或 11 位浮点像素数据类型转换为半精度或单精度浮点值是无损的。半精度或单精度浮点值到 10 位或 11 位浮点值的转换必须 <= 0.5 ULP。对于这些浮点类型，任何导致值小于零的操作都会被钳位为零。

## 7.7.5 具有 5 位指数的 9 位浮点像素数据类型的转换规则

RGB9E5_SharedExponent 共享指数浮点格式使用 5 位作为指数，9 位作为尾数。没有符号位。

从这种格式到半精度或单精度浮点值的转换是无损的，并且对于每个颜色通道计算为 2 ^ (共享指数 - 15) \* (尾数/512)。

从半精度或单精度浮点 RGB 颜色值到此格式的转换按如下方式执行，其中 N 是每个分量的尾数位数 (9)，B 是指数偏差 (15)，Emax 是允许的最大偏差指数值 (31)。

- 限制 r、g 和 b 分量（在此过程中，将 NaN 映射为零），如下所示：

rc = max(0, min(sharedexpmax, r) gc = max(0, min(sharedexpmax, g) bc = max(0, min(sharedexpmax, b)

其中 sharedexpmax = ((2N - 1)/2N) \* 2(Emax - B)。

- 确定最大夹紧分量 maxc：

maxc = max(rc, gc, bc)

- 计算初步共享指数 expp

expp = max(-B - 1, 下限(log2(maxc)) + 1 + B

- 计算精确的共享指数 exps

maxs = Floor((maxc / 2expp-B-N) + 0.5f) exps = expp，如果 0 <= maxs < 2N，并且 exps = expp + 1，如果 maxs = 2N。

- 最后，计算 0 到 2N - 1 范围内的三个整数值：

rs = 下限(rc / 2expp-B-N) + 0.5f) gs = 下限(gc / 2expp-B-N) + 0.5f) bs = 下限(bc / 2expp-B-N) + 0.5f)

将半精度或单精度浮点颜色值转换为 MTLPixelFormatRGB9E5Float 共享指数浮点值 <= 0.5 ULP。

## 7.7.6 有符号和无符号整数像素数据类型的转换规则

对于具有 8 或 16 位有符号或无符号整数像素值的纹理，纹理采样和读取函数返回有符号或无符号 32 位整数像素值。本节中描述的转换必须正确饱和。

对这些整数纹理的写入执行表 7. 8 中列出的转换之一。

## 表 7.8。整数像素数据类型之间的转换

`转换自 到 转换规则`

`32 位有符号整数 8 位有符号整数结果 = Convert_char_saturate(val)`

`32 位有符号整数 16 位有符号整数 结果 = Convert_short_saturate(val)`

`32 位无符号整数`

`8 位无符号整数`

`结果 = Convert_uchar_saturate(val)`

`32 位无符号整数`

`16 位无符号整数`

`结果 = Convert_ushort_saturate(val)`

## 7.7.7 sRGBA 和 sBGRA 纹理的转换规则

Conversion from sRGB space to linear space is automatically done when sampling from an sRGB texture. The conversion from sRGB to linear RGB is performed before the filter specified in the sampler specified when sampling the texture is applied. If the texture has an alpha channel, the alpha data is stored in linear color space.

写入 sRGB 纹理时，会自动完成从线性空间到 sRGB 空间的转换。如果纹理具有 Alpha 通道，则 Alpha 数据存储在线性颜色空间中。

以下是将标准化的 8 位无符号整数从 sRGB 颜色值转换为浮点线性 RGB 颜色值（称为 c）的转换规则：

如果（c <= 0.04045）

结果=c/12.92；

别的

结果 = 功率((c + 0.055) / 1.055, 2.4);

上述转换的精度必须确保将结果转换回非标准化 sRGB 值但不舍入为 8 位无符号整数值（称为 r）时所得无限精确浮点值与原始 sRGB 8 之间的差值位无符号整数颜色值（称为 rorig）<= 0.5；例如：

fabs(r - rorig) <= 0.5

使用以下规则将线性 RGB 浮点颜色值（称为 c）转换为标准化 8 位无符号整数 sRGB 值：

如果 (isnan(c)) c = 0.0;如果 (c > 1.0) c = 1.0；否则如果 (c < 0.0) c = 0.0;否则如果 (c < 0.0031308) c = 12.92 _ c;否则 c = 1.055 _ power(c, 1.0/2.4) - 0.055;

// 转换为整数小数位数: c = c \* 255.0 // 转换为整数: c = c + 0.5 // 去掉小数部分。// 剩余的浮点（整数）值直接转换为整数。

上述转换的精度为：

fabs（参考结果 - 整数结果）< 1.0。

 Apple Inc. 版权所有 © 2018 - 2023 Apple Inc. 保留所有权利。

No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by any means, mechanical, electronic, photocopying, recording, or otherwise, without prior written permission of Apple Inc., with the following exceptions: Any person is hereby authorized to store documentation on a single computer or device for personal use only and to print copies of documentation for personal use provided that the documentation contains Apple’s copyright notice.

对于本文档中描述的任何技术，均未授予任何明示或暗示的许可。Apple 保留与本文档中描述的技术相关的所有知识产权。本文档旨在帮助应用程序开发人员仅为 Apple 品牌产品开发应用程序。

Apple Inc. One Apple Park Way Cupertino, CA 95014 408 - 996 - 1010

Apple is a trademark of Apple Inc., registered in the U.S. and other countries.

**Apple 不对本文档、其质量、准确性、适销性或特定用途的适用性做出任何明示或暗示的保证或陈述。因此，本文档按“原样”提供，你（读者）承担其质量和准确性的全部风险。**

**在任何情况下，Apple 均不对因本文档中的任何缺陷、错误或不准确而导致的直接、间接、特殊、偶然或后果性损害承担责任，即使已被告知发生此类损害的可能性。**

**某些司法管辖区不允许排除默示保证或责任，因此上述排除可能不适用于你。**

```

```
