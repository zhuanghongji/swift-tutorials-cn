# 函数参数和变量

<OrigninalPDF title="5.2 Function Arguments and Variables" />

图形（顶点或片段）和内核函数的大多数输入和输出都作为参数传递。（常量地址空间中的初始化变量和程序范围中声明的采样器是输入和输出，不必作为参数传递。）从 Metal 3.1 开始，内核、网格和对象着色器的内置输入变量现在可以在程序范围内声明，避免将它们作为参数传递。如果它们未在动态库或单独编译的二进制函数中使用，则这适用。

图形和内核函数的参数可以是以下任何一个：

- 设备缓冲区 —— 指向 `device` 地址空间中任何数据类型的指针或引用（参见第 2.8 节）。
- 常量缓冲区 —— 指向 `constant` 地址空间中任何数据类型的指针或引用（参见第 2.8 节）。
- `texture` 对象（参见第 2.9 节）或纹理数组。
- `texture_buffer` 对象（参见第 2.9.1 节）或纹理缓冲区数组。
- `sampler` 对象（参见第 2.10 节）或采样器数组。
- 线程组中的线程之间共享的缓冲区—— 指向 `threadgroup` 地址空间中的类型的指针，只能用作内核函数的参数。
- 图像块（参见第 2.11 节）。
- 参数缓冲区（参见第 2.13 节）。
- 内核函数的可见函数表（参见第 2.15 节）。从 Metal 2.4 开始，可见函数表也可以用于图形函数。
- 核函数的交集函数表（参见第 2.17.3 节）。
- 用于交集函数的加速结构（参见第 6.18.1 节）。
- 包含缓冲区、纹理或纹理缓冲区元素的结构。

指定为图形或内核函数的参数值的缓冲区（设备）不能使用别名；也就是说，作为参数值传递的缓冲区不能与传递给同一图形或内核函数的单独参数的另一个缓冲区重叠。

你不能将图形和内核函数的参数声明为 `size_t`、`ptrdiff_t` 类型，或者包含声明为这些内置标量类型之一的成员的结构和/或联合。

这些函数的参数通常用属性来指定，以提供对其使用的进一步指导。属性用于指定：

- 参数的资源位置（参见第 5.2.1 节）。
- 支持固定功能和可编程流水线级之间数据通信的内置变量（参见第 5.2.3 节）。
- 哪些数据沿着管道从顶点函数发送到片段函数（参见第 5.2.4 节）。

## 定位缓冲区、纹理和采样器参数

对于每个参数，可以选择指定一个属性来标识用于该参数类型的缓冲区、纹理或采样器的位置。Metal 框架 API 使用此属性来标识这些参数类型的位置。

- 设备和常量缓冲区：`[[buffer(index)]]`
- 纹理（包括纹理缓冲区）：`[[texture(index)]]`
- 采样器：`[[sampler(index)]]`
- 线程组缓冲区：`[[threadgroup(index) )]]`

索引值是一个无符号整数，用于标识分配的缓冲区、纹理或采样器参数的位置。（纹理缓冲区是一种特定类型的纹理。）正确的语法是属性遵循参数或变量名称。

下面的示例是一个简单的内核函数 add_vectors，它将设备地址空间中的两个缓冲区 inA 和 inB 的数组相加，并将结果返回到缓冲区 out 中。属性 (`buffer(index)`) 指定函数参数的缓冲区位置。

```cpp
[[kernel]] void add_vectors(const device float4 *inA [[buffer(0)]],
                            const device float4 *inB [[buffer(1)]],
                            device float4 *out [[buffer(2)]],
                            uint id [[thread_position_in_grid]]
) {
    out[id] = inA[id] + inB[id];
}
```

下面的示例显示了用于几种不同类型的函数参数（缓冲区、纹理和采样器）的属性：

```cpp
[[kernel]] void my_kernel(device float4 *p [[buffer(0)]],
                          texture2d<float> img [[texture(0)]],
                          sampler sam [[sampler(1)]]
) {
    // ...
}
```

如果未指定位置索引，Metal 编译器将使用第一个可用的位置索引来分配它们。在以下示例中，为 `src` 分配纹理索引 0、`dst` 纹理索引 1、`s` 采样器索引 0 和 u 缓冲区索引 0：

```cpp
kernel void my_kernel(texture2d<half> src,
                      texture2d<half, access::write> dst,
                      sampler s,
                      device myUserInfo *u
) {
    // ...
}
```

在下面的示例中，一些内核参数已显式分配位置索引，而另一些则没有。`src` 显式分配纹理索引 0，`f` 显式分配缓冲区索引 10。如果使用函数常量分配位置索引（第 5.8 节），则编译器在分配索引时不会考虑这些条目。其它参数分配第一个可用位置索引：`dst` 纹理索引 1、`s` 采样器索引 0 和 `u` 缓冲区索引 0。

```cpp
kernel void my_kernel(texture2d<half> src [[texture(0)]],
                      texture2d<half, access::write> dst,
                      sampler s,
                      device myUserInfo *u,
                      device float *f [[buffer(10)]]
) {
    // ...
}
```

每个属性（`buffer`、`threadgroup`、`texture` 和 `sampler`）代表一组资源。参数上指定的索引值在每个资源组中应是唯一的。具有相同 `index` 的多个缓冲区、纹理或采样器参数会生成编译错误，除非使用函数常量属性声明它们（请参阅第 5.8.1 节）。

### 具有资源和输出到设备内存的顶点函数示例

以下示例是一个顶点函数 `render_vertex`，它输出到数组 `xform_output` 中的设备内存，该数组是使用 `device` 属性指定的函数参数 (在 4.1 节中介绍)。所有的 `render_vertex` 函数参数都是用 `buffer(0)`，`buffer(1)`，`buffer(2)` 和 `buffer(3)` 属性指定的 (在 5.2.1 节中介绍)。有关本例中显示的 `position` 属性的更多信息，请参见 5.2.3.3 节。

```cpp
struct VertexOutput {
    float4 position [[position]];
    float4 color;
    float2 texcoord;
};

struct VertexInput {
    float4 position;
    float3 normal;
    float2 texcoord;
};

constexpr constant uint MAX_LIGHTS = 4;

struct LightDesc {
    uint  num_lights;
    float4 light_position[MAX_LIGHTS];
    float4 light_color[MAX_LIGHTS];
    float4 light_attenuation_factors[MAX_LIGHTS];
};

vertex void render_vertex(const device VertexInput* v_in [[buffer(0)]],
                          constant float4x4& mvp_matrix [[buffer(1)]],
                          constant LightDesc& light_desc [[buffer(2)]],
                          device VertexOutput* xform_output [[buffer(3)]],
                          uint v_id [[vertex_id]]
) {
    VertexOutput v_out;
    v_out.position = v_in[v_id].position * mvp_matrix; v_out.color = do_lighting(v_in[v_id].position,
    v_in[v_id].normal, light_desc);

    v_out.texcoord = v_in[v_id].texcoord;
    // Output the position to a buffer. xform_output[v_id] = v_out;
}
```

### 光栅顺序组

所有操作系统：自 Metal 2 起支持光栅顺序组属性。

片段函数中的缓冲区（在 `device` 内存中）和纹理的加载和存储是无序的。用于缓冲区或纹理的 `[[raster_order_group(index)]]` 属性，如果每个样本着色处于活动状态，则保证映射到相同 `(x, y)` 像素坐标和样本的不同基元的任何重叠片段的访问顺序。

`[[raster_order_group(index)]]` 属性可以在纹理（始终位于 `device` 内存中）或在 `device` 内存中声明的缓冲区上指定，但不能在 `threadgroup` 或 `constant` 地址空间中指定。`[[raster_order_group(index)]]` 属性不能与结构或类一起使用。

使用 `[[raster_order_group(index)]]` 属性标记对缓冲区或纹理的重叠访问的片段函数调用的执行顺序与提交几何图形的顺序相同。对于重叠片段函数调用，片段函数调用对标有 `[[raster_order_group(index)]]` 属性的缓冲区或纹理执行的写入需要可供后续调用读取，并且不得影响先前调用的读取。同样，片段函数调用执行的读取必须反映先前调用的写入，并且不得反映后续调用的写入。

`[[raster_order_group(index)]]` 中的 `index` 是一个整数值，它指定光栅器顺序 ID，它提供对加载和存储顺序的更细粒度的控制。例如，如果两个缓冲区 A 和 B 被标记有不同的光栅器顺序 ID 值，则可以独立地同步对缓冲区 A 和 B 的重叠片段的加载和存储。

例子：

```cpp
fragment void
my_fragment(texture2d<float, access::read_write> texA [[raster_order_group(0),
            texture(0)]],
            ...
) {
    ushort2 coord;
    float4 clr = texA.read(coord);
    // do operations on clr
    clr = ...;
    texA.write(clr, coord);
}
```

对于参数缓冲区，你可以在结构中的缓冲区或纹理成员上使用 `[[raster_order_group(index)]]` 属性。

## 定位每个顶点输入的属性

顶点函数可以通过使用顶点和实例 ID 作为参数传递给顶点函数的缓冲区进行索引来读取每个顶点的输入。此外，你还可以使用 `[[stage_in]]` 属性声明每个顶点输入，并将该输入作为参数传递。对于作为使用 `[[stage_in]]` 属性声明的参数传递的每顶点输入，每顶点输入的每个元素必须将顶点属性位置指定为 `[[attribute(index)]]`。有关 `[[stage_in]]` 属性的更多信息，请参阅第 5.2.4 节。

`index` 是一个无符号整数，用于标识分配的顶点输入位置。正确的语法是属性遵循参数或变量名称。Metal API 使用该属性用于标识顶点缓冲区的位置并描述顶点数据，例如从中获取每个顶点数据的缓冲区、其数据格式及其步幅。

以下示例演示如何将顶点属性分配给使用 `stage_in` 属性传递给顶点函数的顶点输入结构的元素：

```cpp
struct VertexInput {
    float4 position [[attribute(0)]];
    float3 normal   [[attribute(1)]];
    half4 color     [[attribute(2)]];
    half2 texcoord  [[attribute(3)]];
};

constexpr constant uint MAX_LIGHTS = 4;

struct LightDesc {
    uint  num_lights;
    float4 light_position[MAX_LIGHTS];
    float4 light_color[MAX_LIGHTS];
    float4 light_attenuation_factors[MAX_LIGHTS];
};

constexpr sampler s = sampler(coord::normalized,
                              address::clamp_to_zero,
                              filter::linear);

vertex VertexOutput
render_vertex(VertexInput v_in [[stage_in]],
    constant float4x4& mvp_matrix [[buffer(1)]],
    constant LightDesc& lights [[buffer(2)]],
    uint v_id [[vertex_id]]
) {
    VertexOutput v_out;
    ...
    return v_out;
}
```

下面的示例显示了如何使用缓冲区和 `stage_in` 属性来获取顶点函数中的每个顶点输入。

```cpp
struct VertexInput {
    float4 position [[attribute(0)]];
    float3 normal   [[attribute(1)]];
};

struct VertexInput2 {
half4 color;
half2 texcoord[4];
};

constexpr constant uint MAX_LIGHTS = 4;

struct LightDesc {
    uint  num_lights;
    float4 light_position[MAX_LIGHTS];
    float4 light_color[MAX_LIGHTS];
    float4 light_attenuation_factors[MAX_LIGHTS];
};

constexpr sampler s = sampler(coord::normalized,
                              address::clamp_to_zero,
                              filter::linear);

vertex VertexOutput
render_vertex(VertexInput v_in [[stage_in]],
              VertexInput2 v_in2 [[buffer(0)]],
              constant float4x4& mvp_matrix [[buffer(1)]],
              constant LightDesc& lights [[buffer(2)]],
              uint v_id [[vertex_id]]
) {
    VertexOutput vOut;
    ...
    return vOut;
}
```

曲面细分后顶点函数可以读取每个面片和面片控制点数据。曲面细分后顶点函数将面片控制点数据指定为以下模板化类型：

```cpp
patch_control_point<T>
```

其中 `T` 是用户定义的结构。`T` 的每个元素必须使用 `[[attribute(index)]]` 指定属性位置。

所有操作系统：自 Metal 1.2 起支持补丁控制点模板类型。

`patch_control_point` 类型支持以下成员函数：

- `constexpr size_t size() const; `

它返回补丁中控制点的数量。

- `constexpr const_reference operator[] (size_t pos) const;`

它返回 pos 标识的特定斑块控制点的数据。

例子：

```cpp
struct ControlPoint {
    int3 patchParam  [[attribute(0)]];
    float3 P         [[attribute(1)]];
    float3 P1        [[attribute(2)]];
    float3 P2        [[attribute(3)]];
    float2 vSegments [[attribute(4)]];
};

struct PerPatchData {
    float4 patchConstant          [[attribute(5)]];
    float4 someOtherPatchConstant [[attribute(6)]];
};

struct PatchData {
    patch_control_point<ControlPoint> cp; // Control-point data
    PerPatchData patchData;               // Per-patch data
};

[[patch(quad)]] vertex VertexOutput post_tess_vertex_func(PatchData input [[stage_in ]], ...) {
    // ...
}
```

## 内置变量的属性

一些图形操作发生在固定功能流水线阶段，需要向图形函数提供值或从图形函数接收值。内置输入和输出变量用于在图形（顶点和片段）函数和固定功能图形管道阶段之间传递值。属性与图形函数的参数和返回类型一起使用来标识这些内置变量。

### 顶点函数输入属性

表 5.2 列出了可以为顶点函数的参数指定的内置属性以及可以使用它们的相应数据类型。

<TableView
  num="5.2"
  title="Attributes for vertex function input arguments"
  headers={["Attribute", "Corresponding Data Types", "Description"]}
  datasList={[
    [
      "amplification_count \nmacOS: Since Metal 2.3. iOS: Since Metal 2.2.",
      "ushort or uint",
      "The number of output vertices produced for each vertex instance.",
    ],
    [
      "amplification_id \nmacOS: Since Metal 2.3. \niOS: Since Metal 2.2.",
      "ushort or uint",
      "The array index offset mappings for viewport and render target array indices, which enables routing an amplified vertex to a different viewport and render target.",
    ],
    [
      "base_instance",
      "ushort or uint",
      "The base instance value added to each instance identifier before reading per-instance data.",
    ],
    [
      "base_vertex",
      "ushort or uint",
      "The base vertex value added to each vertex identifier before reading per-vertex data.",
    ],
    [
      "instance_id",
      "ushort or uint",
      "The per-instance identifier, which includes the base instance value if one is specified.",
    ],
    [
      "vertex_id",
      "ushort or uint",
      "The per-vertex identifier, which includes the base vertex value if one is specified.",
    ],
  ]}
/>

`[[amplification_count]]` 的默认值为 1，表示禁用顶点放大。

`[[amplification_id]]` 的值应在 `[0, amplification_count]` 范围内。

顶点函数输入属性类型注意事项：

- 如果声明 `[[vertex_id]]` 的类型为 `uint`，则声明 `[[base_vertex]]` 的类型需要为 `uint` 或 `ushort`。
- 如果声明 `[[vertex_id]]` 的类型为 `ushort`，则声明 `[[base_vertex]]` 的类型也需要为 `ushort`。
- 如果声明 `[[instance_id]]` 的类型为 `uint`，则声明 `[[base_instance]]` 的类型需要为 `uint` 或 `ushort`。
- 如果声明 `[[instance_id]]` 的类型为 `ushort`，则声明 `[[base_instance]]` 的类型也需要为 `ushort`。

### 曲面细分后顶点函数输入属性

表 5.3 列出了可以为曲面细分后顶点函数的参数指定的内置属性以及可以使用它们的相应数据类型。

<TableView
  num="5.3"
  title="Attributes for post-tessellation vertex function input arguments"
  headers={["Attribute", "Corresponding Data Types", "Description"]}
  datasList={[
    [
      "base_instance",
      "ushort or uint",
      "The base instance value added to each instance identifier before reading per-instance data.",
    ],
    [
      "instance_id",
      "ushort or uint",
      "The per-instance identifier, which includes the base instance value if one is specified.",
    ],
    ["patch_id", "ushort or uint", "The patch identifier."],
    [
      "position_in_patch",
      "float2 or float3",
      "Defines the location on the patch being evaluated. For quad patches, must be float2. For triangle patches, must be float3.",
    ],
  ]}
/>

所有操作系统：自 Metal 1.2 起支持表 5.3 中的所有属性。

顶点函数输入属性注意事项：

- 如果声明 `[[instance_id]]` 的类型为 `uint`，则声明 `[[base_instance]]` 的类型需要为 `uint` 或 `ushort`。
- 如果声明 `[[instance_id]]` 的类型为 `ushort`，则声明 `[[base_instance]]` 的类型也需要为 `ushort`。

### 顶点函数输出属性

表 5.4 列出了可以为顶点函数的返回类型或顶点函数返回的结构体的成员指定的内置属性（及其相应的数据类型）。

<TableView
  num="5.4"
  title="Attributes for vertex function return type"
  headers={["Attribute", "Corresponding Data Types", "Description"]}
  datasList={[
    ["Attribute", "Corresponding Data Types", "Description"],
    [
      "clip_distance",
      "float or float[n] \nn needs to be known at compile time",
      "Distance from vertex to clipping plane",
    ],
    [
      "invariant \nAll OS: Since Metal 2.1",
      "Not applicable; needs to be used with [[position]]",
      "Marks the output position such that if the sequence of operations used to compute the output position in multiple vertex shaders is identical, there is a high likelihood that the resulting output position computed by these vertex shaders are the same value. Requires users to pass -fpreserve-invariance. Please see description below for more information.",
    ],
    ["point_size", "float", "Size of a point primitive"],
    ["position", "float4", "The transformed vertex position"],
    [
      "render_target_array_ind ex \nmacOS: Since Metal 1.1. \niOS: Since Metal 2.1.",
      "uchar, ushort, or uint",
      "The array index that refers to one of: \n1) an array slice of a texture array, \n2) data at a specified depth of a 3D texture, \n3) the face of a cubemap, or \n4) a specified face of a specified array slice of a cubemap array.",
    ],
    [
      "shared \nmacOS: Since Metal 2.3. \niOS: Since Metal 2.2.",
      "Not applicable",
      "If present, then for every amplification_id, the output shall have the same value.",
    ],
    [
      "viewport_array_index \nmacOS: Since Metal 2. \niOS: Since Metal 2.1.",
      "uchar, ushort, or uint",
      "The viewport (and scissor rectangle) index value of the primitive.",
    ],
  ]}
/>

所有操作系统：自 Metal 1 起支持表 5. 4 中的属性，除非另有说明。

立方体贴图表示为具有六层的渲染目标数组，每个面一层，`[[render_target_array_index]]` 是面索引，其值为 0 到 5 之间的值。对于立方体贴图数组，`[[render_target_array_index]]` 为计算为：`array_slice_index * 6 + face_index`。

你必须为基元中的每个顶点返回相同的 `[[render_target_array_index]]` 值。如果值不同，则传递给片段函数的行为和值未定义。相同的行为适用于由曲面细分生成的图元。如果 `[[render_target_array_index]]` 越界（即大于或等于 `renderTargetArrayLength`），则硬件会将此值解释为 0。有关 `[[render_target_array_index]]` 作为片段函数输入的更多信息，请参阅第 5.2.3.4 节。

`[[viewport_array_index]]` 允许从多个活动视口和剪刀矩形指定一个视口和剪刀矩形。如果顶点函数没有指定 `[[viewport_array_index]]`，则输出视口数组索引值为 0。有关 `[[viewport_array_index]]` 的更多信息，请参见第 5.10 节。

`[[invariant]]` 表示多个函数传递中使用的浮点数学必须生成与每个传递完全匹配的顶点位置。`[[invariant]]` 只能用于顶点函数中的位置（具有 `[[position]]` 属性的字段），以指示输出的计算结果是不变的。在 iOS 14.0 和 macOS 11.0 之前的编译器中，计算可能（尽管不能保证）是不变的。现在，当传递 `-fpreserve-invariance` 选项或从 Metal API 的 `MTLCompilerOptions` 设置 `preserveInvariance` 进行运行时编译时，此计算保证不变。请注意，如果未传递选项，则 `[[invariant]]` 将被忽略。这种位置不变性对于阴影体积或 z-prepass 等技术至关重要。

如果顶点函数的返回类型不是 `void`，则它必须包含顶点位置。如果顶点返回类型是 `float4`，那么它总是引用顶点位置，并且不能指定 `[[position]]` 属性。如果顶点返回类型是结构体，则它必须包含使用 `[[position]]` 属性声明的元素。

以下示例描述了一个名为 `process_vertex` 的顶点函数。该函数返回一个名为 `VertexOutput` 的用户定义结构，其中包含一个表示顶点位置的内置变量，因此需要 `[[position]]` 属性。

```c
struct VertexOutput {
    float4 position [[position]];
    float4 color;
    float2 texcoord;
}

vertex VertexOutput process_vertex(...)
{
    VertexOutput v_out;
    // compute per-vertex output …
    return v_out;
}
```

曲面细分后顶点函数输出与常规顶点函数相同。

如果启用顶点放大，并且顶点输出变量的每个 `[[amplification_id]]` 属性具有相同的值，则顶点输出被视为 _共享_。共享的顶点输出可以使用单个变化的输出槽，这是有限的资源。未共享的顶点输出消耗多个不同的输出槽。（Metal 框架调用 `[MTLRenderPipelineDescriptor maxVertexAmplificationCount]` 返回可用于将放大的数据传递到片段函数调用的变化槽的数量，这会影响可用变化槽的总数。）

默认情况下，所有内置顶点输出都是共享的，除了具有 `[[position]]` 属性的顶点输出。默认情况下，不共享所有其它顶点输出。要显式指定输出是共享的，请将 `[[shared]]` 属性与顶点输出变量一起使用。

如果着色器编译器可以推断出顶点输出变量对于每个 `amplification_id` 具有相同的值，则编译器可以将该顶点输出标记为共享。在以下任何情况下，编译器可能不会将顶点输出标记为共享：

- 输出值取决于 `[[amplification_id]]`。
- 原子 read-modify-write 操作返回输出值。
- 着色器从易失性存储器加载输出值。

### 片段函数输入属性

表 5.5 列出了可以为片段函数的参数指定的内置属性（及其相应的数据类型）。

如果顶点函数的返回类型不是 `void`，则它必须包含顶点位置。如果顶点返回类型是 `float4`，则它始终指的是顶点位置（并且不需要指定 `[[position]]` 属性）。如果顶点返回类型是结构体，则它必须包含使用 `[[position]]` 属性声明的元素。

<TableView
  num="5.5"
  title="Attributes for fragment function input arguments"
  headers={["Attribute", "Corresponding Data Types", "Description"]}
  datasList={[
    [
      "amplification_count \nmacOS: Since Metal 2.3. \niOS: Since Metal 2.2.",
      "ushort or uint",
      "The number of output vertices produced for each vertex instance.",
    ],
    [
      "amplification_id \nmacOS: Since Metal 2.3. \niOS: Since Metal 2.2.",
      "ushort or uint",
      "The array index offset mappings for viewport and render target array indices, which enables routing an amplified vertex to a different viewport and render target.",
    ],
    [
      "barycentric_coord \nmacOS: Since Metal 2.2. \niOS: Since Metal 2.3.",
      "float, float2, or float3",
      "The barycentric coordinates.",
    ],
    [
      "color(m) \nmacOS: Since Metal 2.3. \niOS: Since Metal 1.",
      "floatn, halfn, intn, uintn, shortn, or ushortn \nm needs to be known at compile time",
      "The input value read from a color attachment. The index m indicates which color attachment to read from.",
    ],
    [
      "front_facing",
      "bool",
      "This value is true if the fragment belongs to a front-facing primitive.",
    ],
    [
      "point_coord",
      "float2",
      "Two-dimensional coordinates, which range from 0.0 to 1.0 across a point primitive, specifying the location of the current fragment within the point primitive.",
    ],
    [
      "position",
      "float4",
      "Describes the window-relative coordinate (x, y, z, 1/w) values for the fragment.",
    ],
    [
      "primitive_id \nmacOS: Since Metal 2.2. \niOS: Since Metal 2.3.",
      "uint",
      "The per-primitive identifier used with barycentric coordinates.",
    ],
    [
      "render_target_array_index \nmacOS: Since Metal 1.1. \niOS: Since Metal 2.1.",
      "uchar, ushort, or uint",
      "The render target array index, which refers to the face of a cubemap, data at a specified depth of a 3D texture, an array slice of a texture array, an array slice, or face of a cubemap array. For a cubemap, the render target array index is the face index, which is a value from 0 to 5. For a cubemap array the render target array index is computed as: array slice index * 6 + face index.",
    ],
    [
      "sample_id",
      "uint",
      "The sample number of the sample currently being processed.",
    ],
    [
      "sample_mask",
      "uint",
      "The set of samples covered by the primitive generating the fragment during multisample rasterization.",
    ],
    [
      "sample_mask, post_depth_coverage \niOS: Since Metal 2. \nmacOS: Since Metal 2.3",
      "uint",
      "The set of samples covered by the primitive generating the fragment after application of the early depth and stencil tests during multisample rasterization. The early_fragment_tests attribute needs to be used on the fragment function; otherwise the compilation fails.",
    ],
    [
      "thread_index_in_quadgroup \nAll OS: Since Metal 2.2.",
      "ushort or uint",
      "The scalar index of a thread within a quad-group.",
    ],
    [
      "thread_index_in_simdgro up \nAll OS: Since Metal 2.2.",
      "ushort or uint",
      "The scalar index of a thread within a SIMD-group.",
    ],
    [
      "threads_per_simdgroup \nAll OS: Since Metal 2.2.",
      "ushort or uint",
      "The thread execution width of a SIMD-group.",
    ],
    [
      "viewport_array_index \nmacOS: Since Metal 2. \niOS: Since Metal 2.1.",
      "uint",
      "The viewport (and scissor rectangle) index value of the primitive.",
    ],
  ]}
/>

使用 `[[position]]` 属性声明为片段函数输入的变量只能使用 `center_no_perspective` 采样和插值属性声明。（参见第 5.4 节。）

对于 `[[color(m)]]`，`m` 用于在片段函数中访问（读取或写入）多个颜色附件时指定颜色附件索引。

对于片段函数输入，`[[sample_mask]]` 属性只能声明一次。

片段函数中 `[[render_target_array_index]]` 的值与从顶点函数写入的值相同，即使指定的值超出范围。

有关 `[[viewport_array_index]]` 的更多信息，请参阅第 5.10 节。

`[[amplification_count]]` 的默认值为 1，表示禁用顶点放大。

`[[amplification_id]]` 的值应在 `[0, amplification_count)` 范围内。

对于指定的 `[[amplification_id]]` 属性值，`[[viewport_array_index]]` 和 `[[render_target_array_index]]` 内置片段输入值将添加到相应 `MTLVertexAmplificationViewMapping` 结构提供的值（偏移）。

以下示例描述了结构体 `MyVertexOut`，它既是顶点函数返回类型又是片段函数输入类型。`MyVertexOut` 使用输入参数 `amp_id` 的 `[[amplification_id]]` 属性来放大位置和 `ampData` 成员。使用 `[[shared]]` 属性显式确保 `texcoord` 成员在顶点放大下对于所有变量具有相同的值，如第 5.2.3.3 节所述。

在顶点函数 `myVertex` 中，`[[amplification_id]]` 和 `[[amplification_count]]` 属性指定用于顶点放大的顶点函数输入变量，详见 5.2.3.1 节。着色器编译器推断出每个 `[[amplification_id]]` 的普通成员具有相同的值，因此编译器在顶点输出中将其标记为共享。

在片段函数 `myFragment` 中，相同的 `[[amplification_id]]` 和 `[[amplification_count]]` 属性指定片段函数输入变量。如果启用顶点放大，则 `amp_id` 确定从中选择视口数组索引（`viewportArrayIndexOffset` 成员）的映射（`MTLVertexAmplificationViewMapping` 结构）。

```cpp
struct MyVertexIn {
    float4 position [[attribute(0)]];
    float3 normal   [[attribute(1)]];
    float3 tangent  [[attribute(2)]];
    float2 texcoord [[attribute(3)]];
};

struct MyVertexOut {
    float4 position [[position]];
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float2 texcoord [[shared]]; // explicitly shared.
    float  ampData;
    ushort viewport [[viewport_array_index]]; // implicitly shared
};

constexpr ushort MAX_AMP = 2;

vertex MyVertexOut myVertex(MyVertexIn in [[stage_in]],
                            constant float4x4 view_proj[MAX_AMP],
                            constant float data[MAX_AMP],
                            ushort amp_id [[amplification_id]],
                            ushort amp_count [[amplification_count]], ...) {
    MyVertexOut vert;
    vert.position  = view_proj[amp_id] * in.position; // deduced amplified     vert.normal    = in.normal; // deduced shared
    vert.tangent   = ...;
    vert.bitangent = ...;
    vert.texcoord  = ...;
    vert.ampData   = data[amp_id]; // not shared
    vert.viewport  = 1;
    return vert;
}

fragment float4 myFragment(MyVertexOut in [[ stage_in ]],
                           ushort amp_id [[amplification_id]],
                           ushort amp_count [[amplification_count]],
                           ...) {
    // For MTLVertexAmplificationViewMapping = {{1,3},{2,4}}
    //   when amp_id == 0, in.viewport == 2
    //   when amp_id == 1, in.viewport == 3
    ushort viewport = in.viewport;
    ...
}
```

使用 `[[barycentric_coord]]` 属性声明的片段函数输入只能使用 `center_perspective`（默认）或 `center_no_perspective` 采样和插值属性进行声明。重心坐标和每像素基元 ID 可以作为片段函数输入传递到按以下示例所示组织的结构中：

```cpp
struct FragmentInput0 {
    uint primitive_id [[primitive_id]];
    // [[center_perspective]] is the default, so it can be omitted.
    float3 barycentric_coord [[barycentric_coord, center_perspective]];
};

struct FragmentInput1 {
    uint primitive_id [[primitive_id]];
    float2 linear_barycentric_coord [[barycentric_coord,
                                      center_no_perspective]];
};
```

通过存储重心坐标和每像素图元 ID，着色器可以在片段阶段内手动读取和插入绘制图元的顶点，或将此插值推迟到单独的通道。在延迟插值场景下，可以使用 thin buffer

在几何通道期间存储最小的表面数据集，包括预裁剪的重心坐标。在稍后阶段，你必须有足够的数据来根据图元 ID 数据重建原始顶点索引，并将重心坐标与这些顶点索引相关联。

当将 `barycentric_coord` 属性应用于具有 _more_ 组件的输入参数（或参数的字段）时，其余元素将使用 `0.0f` 进行初始化。例如，对于

```cpp
fragment float4
frag (float3 coord [[barycentric_coord]]) { ... }
```

- 绘制点时，`coord.yz` 为 `float2(0.0f)`。
- 画线时，`coord.z` 为 `0.0f`。

当将 `barycentric_coord` 属性应用于具有 _fewer_ 分量的输入参数（或参数的字段）时，其余元素将被忽略。

表 5.6 列出了可以为片段函数输入的图块参数指定的属性。声明 `[[pixel_position_in_tile]]` 和 `[[pixels_per_tile]]` 的数据类型必须匹配。

<TableView
  num="5.6"
  title="Attributes for fragment function tile input arguments"
  headers={["Attribute", "Corresponding Data Types", "Description"]}
  datasList={[
    [
      "pixel_position_in_tile",
      "ushort2 or uint2",
      "(x, y) position of the fragment in the tile.",
    ],
    [
      "pixels_per_tile",
      "ushort2 or uint2",
      "(width, height) of the tile in pixels.",
    ],
    ["tile_index", "ushort or uint", "1D tile index."],
    [
      "render_target_array_index",
      "uchar, ushort, or uint",
      "The render target array index, which refers to the face of a cubemap, data at a specified depth of a 3D texture, an array slice of a texture array, an array slice, or face of a cubemap array. For a cubemap, the render target array index is the face index, which is a value from 0 to 5. For a cubemap array the render target array index is computed as: array slice index * 6 + face index.",
    ],
  ]}
/>

macOS：自 Metal 2.3 起支持表 5.6 中的属性。

iOS：自 Metal 2 起支持表 5.6 中的属性。

`[[tile_index]]` 是 `[0, n)` 中的值，其中 `n` 是渲染目标中的图块数量。

### 片段函数输出属性

片段函数的返回类型描述了每个片段的输出。你必须使用表 5.7 中列出的属性来指定片段函数可以输出一个或多个渲染目标颜色值、深度值、采样覆盖遮罩或模板参考值。如果片段函数没有输出深度值，则将光栅化器生成的深度值输出到深度附件。

<TableView
  num="5.7"
  title="Attributes for fragment function return types"
  headers={["Attribute", "Corresponding Data Types", "Description"]}
  datasList={[
    [
      "color(m) \nAll OS: Since Metal 1. \n\ncolor(m), index(i) \nAll OS: Since Metal 1.2.",
      "floatn, halfn, intn, uintn, shortn, or ushortn",
      "Color value output for a color attachment. \nm is the color attachment index and needs to be known at compile time. The index i can be used to specify one or more colors output by a fragment function for a given color attachment and is an input to the blend equation.",
    ],
    [
      "depth(depth_argument) \nAll OS: Since Metal 1.",
      "float",
      "Depth value output using the function specified by depth_argument.",
    ],
    ["sample_mask \nAll OS: Since Metal 1.", "uint", "Coverage mask."],
    [
      "stencil \nAll OS: Since Metal 2.1.",
      "uint",
      "Stencil reference value to be used in a stencil test.",
    ],
  ]}
/>

片段输出的颜色附件索引 `m` 的指定方式与片段输入的 `[[color(m)]]` 的指定方式相同（参见表 5.5 的讨论）。片段函数返回类型中使用相同颜色附件索引进行混合的多个元素需要使用相同的数据类型进行声明。

如果片段函数中只有单色附件，则 `[[color(m)]]` 是可选的。如果不指定 `[[color(m)]]`，则附件索引为 0。如果指定多个颜色附件，则需要为所有颜色值指定 `[[color(m)]]`。请参阅第 5.5 节和第 5.8.1.5 节中指定颜色附件的示例。

如果属性中未指定 `index(i)`，则默认索引为 `0`。如果指定了 `index(i)`，则需要在编译时知道 `i` 的值。

如果片段函数写入深度值，则需要使用以下值之一指定 `depth_argument`：

- `any`
- `greater`
- `less`

你不能在基于片段的图块着色函数中使用 `[[stencil]]` 属性。`[[stencil]]` 属性与 `[[early_fragment_tests]]` 函数属性不兼容。

如果片段函数没有输出模板值，`MTLRenderCommandEncoder` 的 `setStencilReferenceValue:` 或 `setStencilFrontReferenceValue:backReferenceValue:` 方法可以设置模板参考值。

以下示例显示了如何指定颜色附件索引。`clr_f` 中写入的颜色值写入颜色附件索引 0，`clr_i` 写入颜色附件索引 1，`clr_ui` 写入颜色附件索引 2。

```c
struct MyFragmentOutput {
    // color attachment 0
    float4 clr_f [[color(0)]];

    // color attachment 1
    int4 clr_i [[color(1)]];

    // color attachment 2
    uint4 clr_ui [[color(2)]];
}

fragment MyFragmentOutput my_fragment(...) {
    MyFragmentOutput f;
    ...
    f.clr_f = ...;
    ...
    return f;
}
```

如果颜色附件索引既用作片段函数的输入又用作片段函数的输出，则与使用此颜色附件索引声明的输入参数和输出关联的数据类型必须匹配。

### 内核函数输入属性

当内核函数被提交执行时，它会在 N 维线程网格上执行，其中 N 为一、二或三。线程是内核函数的一个实例对该网格中的每个点执行，并且 `thread_position_in_grid` 标识其在网格中的位置。

在计算单元内，线程组被划分为多个较小的组来执行。计算单元的执行宽度（称为 `threads_per_simdgroup`）决定了该较小组的建议大小。为了获得最佳性能，请将线程组中的线程总数设置为 `threads_per_simdgroup` 的倍数。

线程组在网格内被分配一个唯一的位置（称为 `threadgroup_position_in_grid`）。线程在线程组内被分配一个唯一的位置（称为 `thread_position_in_threadgroup`）。线程组内线程的唯一标量索引由 `thread_index_in_threadgroup` 给出。

每个线程在网格中的位置和在线程组中的位置都是 N 维元组。使用与线程类似的方法为线程组分配位置。线程被分配到一个线程组，并在线程组中指定一个位置，其组件的范围从零到该维度中线程组大小的大小减一。

当内核函数提交执行时，指定线程组的数量和线程组大小，或者指定网格中的线程数和线程组大小。例如，考虑提交执行的内核函数，该函数使用 2D 网格，其中指定的线程组数量为 (`Wx`, `Wy`)，线程组大小为 (`Sx`, `Sy`)。令 `(wx, wy)` 为每个线程组在网格中的位置 (`threadgroup_position_in_grid`)，`(lx, ly)` 为每个线程在线程组中的位置 (`thread_position_in_threadgroup`)。

网格中的线程位置（`thread_position_in_grid`）为：

```
(gx, gy) = (wx * Sx + lx, wy * Sy + ly)
```

网格大小（`threads_per_grid`）为：

```
(Gx, Gy) = (Wx * Sx, Wy * Sy)
```

在除图块函数之外的情况下，线程组中的线程索引 (thread_index_in_threadgroup) 由以下公式确定：`ly * Sx + lx`

对于图块函数，线程索引不是 lx 和 ly 值的线性映射。瓦片函数中的每个线程都保证获得 `[0, Sx \* Sy)` 范围内的唯一索引。

在线程组内，线程以实现定义的方式分为 SIMD-group。SIMD-group 中的任何给定线程都可以查询其 SIMD 通道 ID 以及它属于哪个 SIMD-group。

表 5.8 列出了可以为内核函数的参数指定的内置属性以及可以使用它们的相应数据类型。从 Metal 3.1 开始，可以在要在内核上下文中使用的全局（程序范围）变量上指定内置属性。

<TableView
  num="5.8"
  title="Attributes for kernel function input arguments"
  headers={["Attribute", "Corresponding Data Types", "Description"]}
  datasList={[
    [
      "dispatch_quadgroups_per_th readgroup \nmacOS: Since Metal 2.1. \niOS: Since Metal 2.",
      "ushort or uint",
      "The quad-group execution width of a threadgroup specified at dispatch.",
    ],
    [
      "dispatch_simdgroups_per_threadgroup \nmacOS: Since Metal 2. \niOS: Since Metal 2.2.",
      "ushort or uint",
      "The SIMD-group execution width of a threadgroup specified at dispatch.",
    ],
    [
      "dispatch_threads_per_threadgroup \nAll OS: Since Metal 1.",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The thread execution width of a threadgroup for threads specified at dispatch.",
    ],
    [
      "grid_origin \nAll OS: Since Metal 1.2.",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The origin (offset) of the grid over which compute threads that read per-thread stage-in data are launched.",
    ],
    [
      "grid_size \nAll OS: Since Metal 1.2.",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The maximum size of the grid over which compute threads that read per-thread stage-in data are launched.",
    ],
    [
      "quadgroup_index_in_threadgroup \nmacOS: Since Metal 2.1. \niOS: Since Metal 2.",
      "ushort or uint",
      "The scalar index of a quad-group within a threadgroup.",
    ],
    [
      "quadgroups_per_threadgroup \nmacOS: Since Metal 2.1. \niOS: Since Metal 2.",
      "ushort or uint",
      "The quad-group execution width of a threadgroup.",
    ],
    [
      "simdgroup_index_in_threadgroup \nmacOS: Since Metal 2. \niOS: Since Metal 2.2.",
      "ushort or uint",
      "The scalar index of a SIMD-group within a threadgroup.",
    ],
    [
      "simdgroups_per_threadgroup \nmacOS: Since Metal 2. \niOS: Since Metal 2.2.",
      "ushort or uint",
      "The SIMD-group execution width of a threadgroup.",
    ],
    [
      "thread_execution_width \nAll OS: Since Metal 1. \n[[ Deprecated as of Metal 3 - use threads_per_simdgroup ]]",
      "ushort or uint",
      "The thread execution width of a SIMD-group (compute unit).",
    ],
    [
      "thread_index_in_quadgroup \nmacOS: Since Metal 2.1. \niOS: Since Metal 2.",
      "ushort or uint",
      "The scalar index of a thread within a quad-group.",
    ],
    [
      "thread_index_in_simdgroup \nmacOS: Since Metal 2. \niOS: Since Metal 2.2.",
      "ushort or uint",
      "The scalar index of a thread within a SIMD-group.",
    ],
    [
      "thread_index_in_threadgrou p \nAll OS: Since Metal 1.",
      "ushort or uint",
      "The scalar index of a thread within a threadgroup.",
    ],
    [
      "thread_position_in_grid \nAll OS: Since Metal 1.",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The thread’s position in an N-dimensional grid of threads.",
    ],
    [
      "thread_position_in_threadg roup \nAll OS: Since Metal 1.",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The thread’s unique position within a threadgroup",
    ],
    [
      "threadgroup_position_in_grid \nAll OS: Since Metal 1.",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The threadgroup’s unique position within a grid.",
    ],
    [
      "threadgroups_per_grid \nAll OS: Since Metal 1.",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The number of threadgroups in a grid.",
    ],
    [
      "threads_per_grid \nAll OS: Since Metal 1.",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The grid size.",
    ],
    [
      "threads_per_simdgroup \nmacOS: Since Metal 2. \niOS: Since Metal 2.2.",
      "ushort or uint",
      "The thread execution width of a SIMD-group (compute unit).",
    ],
    [
      "threads_per_threadgroup \nAll OS: Since Metal 1.",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The thread execution width of a threadgroup.",
    ],
  ]}
/>

所有操作系统：自 Metal 1.2 起，支持 `grid_origin` 和 `grid_size`。

macOS：从 Metal 2 开始，支持 SIMD-group 属性。从 Metal 2.1 开始，支持 quad-group 属性。自 Metal 1 以来支持的其它属性。

iOS：从 Metal 2 开始，支持 quad-group 属性。从 Metal 2 开始，支持 SIMD-group 属性。

自 Metal 1 以来支持的其它属性。

所有操作系统：从 Metal 3.1 开始，全局（程序范围）变量现在可以指定这些属性，除非它们在动态库或单独编译的二进制函数中使用。

对于标准 Metal 计算函数（平铺函数除外）， SIMD-group 是线性的和一维的。（线程组可以是多维的。）线程组中的 SIMD-group 数量（`[[simdgroups_per_threadgroup]]`）是线程组中的线程总数（`[[threads_per_threadgroup]]`）除以 SIMD-group 大小（`[[threads_per_simdgroup]]`）：

```c
simdgroups_per_threadgroup = ceil(threads_per_threadgroup / threads_per_simdgroup)
```

同样，线程组中的四元组数量（`quadgroups_per_threadgroup`）是线程组中的线程总数除以 4，即四元组的线程执行宽度：

```c
quadgroups_per_threadgroup = ceil(threads_per_threadgroup / 4)
```

对于平铺函数，线程排列为 2 x 2 四边形。对于指定线程组数量为 `(Wx, Wy)` 的 2 D 网格，`simdgroups_per_threadgroup` 计算如下：

```c
simdgroups_per_threadgroup = ceil(Wx / 2) * 2 * ceil(Wy / 2) * 2 / threads_per_simdgroup
simdgroups_per_threadgroup = ceil(Wx / 2) * ceil(Wy / 2) * 4 / threads_per_simdgroup
```

对于图块函数，`quadgroups_per_threadgroup` 的计算方式如下：

```c
quadgroups_per_threadgroup = ceil(Wx / 2) * 2 * ceil(Wy / 2) * 2 / 4
quadgroups_per_threadgroup = ceil(Wx / 2) * ceil(Wy / 2)
```

对于调度时指定的线程，`[[dispatch_simdgroups_per_threadgroup]]` 和 `[[dispatch_quadgroups_per_threadgroup]]` 的计算方式类似。

SIMD-group 在给定线程组内并发执行，并在没有线程组屏障操作的情况下相互独立地前进。SIMD-group 中的线程索引（由 `[[thread_index_in_simdgroup]]` 给出）是介于 0 和 SIMD-group 大小 - 1 之间的值（包含 0 和 1）。类似地，四元组中的线程索引（由 `[[thread_index_in_quadgroup]]` 给出）是 0 到 3 之间的值（包含 0 和 3）。

在 Metal 2 中，网格中的线程数量不必是线程组中线程数量的倍数。因此，特定线程组的实际线程组大小可能小于调度中指定的线程组大小。`[[threads_per_threadgroup]]` 属性指定执行内核的给定线程组的实际线程组大小。`[[dispatch_threads_per_threadgroup]]` 属性是调度时指定的线程组大小。

核函数属性注意事项：

- 声明 `[[thread_position_in_grid]]`、`[[threads_per_grid]]`、`[[thread_position_in_threadgroup]]`、`[[threads_per_threadgroup]]`、`[[threadgroup_position_in_grid]]`、`[[dispatch_threads_per_threadgroup]]` 和 `[[threadgroups_per_grid]]` 的类型必须是标量类型或向量类型。如果它是向量类型，则用于声明这些参数的向量类型的组件数量需要匹配。
- 声明 `[[thread_position_in_grid]]` 和 `[[threads_per_grid]]` 的数据类型需要匹配。
- 声明 `[[thread_position_in_threadgroup]]`、`[[threads_per_threadgroup]]` 和 `[[dispatch_threads_per_threadgroup]]` 的数据类型需要匹配。
- 如果 `[[thread_position_in_threadgroup]]` 为 `uint`、`uint2` 或 `uint3` 类型，则 `[[thread_index_in_threadgroup]]` 需要为 `uint` 类型。
- 用于声明 `[[thread_index_in_simdgroup]]`、`[[threads_per_simdgroup]]`、`[[simdgroup_index_in_threadgroup]]`、`[[simdgroups_per_threadgroup]]`、`[[dispatch_simdgroups_per_threadgroup]]`、`[[quadgroup_index_in_threadgroup]]`、`[[quadgroups_per_threadgroup]]` 和 `[[dispatch_quadgroups_per_threadgroup]]` 的类型需要为 `ushort` 或 `uint`。声明这些内置变量的类型需要匹配。
- `[[threads_per_simdgroup]]` 和 `[[thread_execution_width]]` 是引用相同概念的彼此的别名。

<TableView
  num="5.9"
  title="Attributes for kernel function tile input arguments"
  headers={["Attribute", "Corresponding Data Types", "Description"]}
  datasList={[
    [
      "render_target_array_index",
      "uchar, ushort, or uint",
      "The render target array index, which refers to the face of a cubemap, data at a specified depth of a 3D texture, an array slice of a texture array, an array slice, or face of a cubemap array. For a cubemap, the render target array index is the face index, which is a value from 0 to 5. For a cubemap array the render target array index is computed as: array slice index * 6 + face index. ",
    ],
  ]}
/>

macOS：自 Metal 2.3 起支持表 5.9 中的属性。

iOS：从 Metal 2 开始支持表 5.9 中的属性。

### 交集函数输入属性

表 5.10 列出了可以为自定义交集函数的参数指定的内置属性（请参阅第 5.1.6 节）。当在交集函数上指定 `primitive_type` 和 `intersection_tags` 的特定值时，可以使用一些内置属性。

例如，如果 `intersection_tags` 包含 `instancing`，则 `instance_id` 可用。

```cpp
[[intersection(triangle, triangle_data, instancing, world_space_data)]]
          bool triangleIntersectionFunction(..., uint id [[instance_id]], ...
) {
      // ...
}
```

任何此类限制都列在属性的描述中。

<TableView
  num="5.10"
  title="Attributes for intersection function input arguments"
  headers={["Attribute", "Corresponding Data Types", "Description"]}
  datasList={[
    ["origin", "float3", "Ray origin in object space."],
    ["direction", "float3", "Ray direction in object space."],
    ["min_distance", "float", "Ray min distance."],
    [
      "max_distance",
      "float",
      "Passed by reference. Returns the current closest intersection max distance. The intersector initializes the initial value with the ray’s maximum distance and the value decreases as the intersector finds intersections.",
    ],
    [
      "payload",
      "User type. \nPassed by reference.",
      "User defined payload passed by the calling thread. Needs to be specified to allow matching payload table by intersect()(section 6.18.2).",
    ],
    ["geometry_id", "ushort or uint", "The per-geometry id."],
    [
      "primitive_id",
      "ushort or uint",
      "The per-primitive identifier. For curves, this is a curve segment index.",
    ],
    [
      "instance_id",
      "ushort, uint or array_ref<uint>",
      "The per-instance identifier. Available if intersection_tags include instancing. Since Metal 3.1, if intersection_tags include max_levels<Count>, the type must be array_ref<uint>. Otherwise, it is ushort or uint.",
    ],
    [
      "world_space_origin",
      "float3",
      "Origin in world space. Available if intersection_tags include world_space_data.",
    ],
    [
      "world_space_direction",
      "float3",
      "Direction in world space. Available if intersection_tags include world_space_data.",
    ],
    [
      "barycentric_coord",
      "float2",
      "The barycentric coordinates. Available if the primitive_type is triangle and intersection tag include triangle_data.",
    ],
    [
      "front_facing",
      "bool",
      "This value is true if the triangle front face is visible from the ray origin. Available if intersection_tags include triangle_data.",
    ],
    [
      "distance",
      "float",
      "Distance along the ray at the triangle intersection. Available if the primitive_type is triangle.",
    ],
    [
      "opaque",
      "bool",
      "If this primitive should be considered opaque or not. Available if the primitive_type is a bounding_box.",
    ],
    [
      "instance_intersection_ function_table_offset",
      "ushort or uint",
      "Offset into the intersection function table used to select the intersection instance.",
    ],
    [
      "geometry_intersection_function_table_offset",
      "ushort or uint",
      "Offset into the geometry object used to select to select the intersection instance.",
    ],
    [
      "time \nAll OS: Since Metal 2.4.",
      "float",
      "Ray intersection time. Available if intersection_tags include primitive_motion.",
    ],
    [
      "motion_start_time \nAll OS: Since Metal 2.4.",
      "float",
      "Motion start time for this geometry. Available if intersection_tags include primitive_motion.",
    ],
    [
      "motion_end_time \nAll OS: Since Metal 2.4.",
      "float",
      "Motion end time for this geometry. Available if intersection_tags include primitive_motion.",
    ],
    [
      "key_frame_count \nAll OS: Since Metal 2.4.",
      "ushort or uint",
      "Number of key frames. Available if intersection_tags include primitive_motion.",
    ],
    [
      "object_to_world_transform \nAll OS: Since Metal 2.4.",
      "float4x3",
      "Object space to world space transformation matrix. Available if intersection_tags include instancing and world_space_data. If intersection_tags include instance_motion, the matrix is interpolated based on the time.",
    ],
    [
      "world_to_object_transform \nAll OS: Since Metal 2.4.",
      "float4x3",
      "World space to object space transformation matrix. Available if intersection_tags include instancing and world_space_data. If intersection_tags include instance_motion, the matrix is interpolated based on the time.",
    ],
    [
      "user_instance_id \nAll OS: Since Metal 2.4.",
      "ushort, uint or array_ref<uint>",
      "User defined instance id. Available if intersection_tags include instancing. Since Metal 3.1, if intersection_tags include max_levels<Count>, the type must be array_ref<uint>. Otherwise, it is ushort or uint.",
    ],
    [
      "primitive_data \nSince Metal 3.",
      "const device T* or const device T&",
      "Per-primitive data. The data is read-only and passed in the device address space.",
    ],
    [
      "curve_parameter \nSince Metal 3.1",
      "float",
      "The value which would need to be passed to the curve basis functions to reconstruct the position corresponding to the intersection along the curve segment. This will be exactly 0.0F or 1.0F if, and only if, the ray intersects a curve end cap or elbow. Available if intersection_tags include curve_data. See section 6.18.6 for a set of curve utility functions.",
    ],
  ]}
/>

对于顶点属性 `v0`、`v1` 和 `v2`，指定重心点处的属性值为：

```c
v1 * barycentric_coord.x +
v2 * barycentric_coord.y +
v0 * (1.0f - (barycentric_coord.x + barycentric_coord.y))
```

具有 `[[payload]]` 属性的参数的类型采用 `ray_data T &` 形式。它通过引用传递给交集函数，并分配在 `ray_data` 地址空间中。有效负载的类型 `T` 可以是或包含以下类型：

- `device` 或 `constant` 指针或引用
- 整数类型
- 枚举类型
- 浮点类型
- 向量类型
- 此类类型的数组
- 结构体和联合体（`atomic<T'>` 和 `imageblock<T'>` 除外）。

### 交集函数输出属性

表 5.11 列出了可以为 `[[intersection(primitive_type, intersection_tags...)]]` 函数的返回类型指定的内置属性（及其相应的数据类型）。

<TableView
  num="5.11"
  title="Attributes for intersection return types"
  headers={["Attribute", "Corresponding Data Types", "Description"]}
  datasList={[
    [
      "accept_intersection",
      "bool",
      "If true, this primitive becomes the next committed hit: if it is the nearest, it will be returned from intersect().",
    ],
    [
      "continue_search",
      "bool",
      "If the hit is accepted ([[accept_intersection]] == true), continue_search indicates if the search should continue. If continue_search is true, intersect() will continue to search for a closer hit. If false, no further searching is done. The current nearest hit is returned from intersect(). Defaults to true. Even if true is returned, a committed hit will immediately halt searching if accept_any_intersection() is true.",
    ],
    [
      "distance",
      "float",
      "This returns the distance along the ray of a hit found within the bounding box. If the hit is rejected ([[accept_intersection]] == false), this return value is ignored. Available if the primitive_type is a bounding_box.",
    ],
  ]}
/>

对于三角形交集函数，`[[accept_intersection]]` 是唯一需要的返回值。如果函数返回一个不带属性的 `bool`，则假定为 `[[accept_intersection]]`。

`[[distance]]` 的值需要大于或等于 `[[min_distance]]` 的值，并且需要小于或等于 `[[max_distance]]` 的值，并且在自定义图元的边界框内（包括在内），或者结果未定义。如果 `[[distance]]` 的值与 `[[max_distance]]` 的值相同，则接受此命中优先于相同距离的前一个命中。

无论交集函数如何返回，对光线有效负载所做的任何更改都会生效：被拒绝的基元可能会对内存产生副作用，这些副作用可以由未来的交集着色器线程观察到。

即使对于被拒绝的原语，也会写入设备内存。这些写入通过通常的内存一致性和一致性规则对其它线程可见（目前，只有原子是一致的，并且仅支持宽松的一致性）。即使光线不与图元的边界框相交，也可以调用相交函数。例如，实现可以将多个基元分组到一个加速结构叶节点中。

下面是边界框的交集函数的示例。

```cpp
struct IntersectionResult {
    bool continueSearch [[continue_search]];
    bool accept [[accept_intersection]];
    float distance [[distance]];
};

[[intersection(bounding_box)]] IntersectionResult sphereIntersectionFunction(
        float3 origin [[origin]],
        float3 direction [[direction]],
        uint primitiveIndex [[primitive_id]],
        ray_data float2& resources [[payload]],
        float min_distance [[min_distance]],
        float max_distance [[max_distance]]
) {
    // ...
}
```

### 对象函数输入属性

所有操作系统：自 Metal 3 起

所有操作系统：从 Metal 3.1 开始，全局变量现在可以指定这些属性，除非在动态库或单独编译的二进制函数中使用。

对象函数使用与内核函数相同的执行模型（参见第 5.2.3.6 节），它在 N 维线程网格上执行。对象函数参数可以是 `samplers`、`textures`、`mesh_grid_properties` 类型的参数以及 `device`、`constant` 和 `threadgroup` 地址空间中的缓冲区。

对象函数支持内核函数的内置属性的子集以及 `[[amplification_count]]` 和 `[[payload]]`。`[[amplification_count]]` 的语义与第 5.2.3.1 节顶点函数输入属性中的相同。表 5. 12 列出了可以为对象函数的参数指定的内置属性以及可以使用它们的相应数据类型。从 Metal 3.1 开始，表 5. 12 中的内置属性可以在程序范围变量上指定，但 `amplification_count` 和 `payload` 除外。

<TableView
  num="5.12"
  title="Attributes for Object Function"
  headers={["Attribute", "Corresponding Data Types", "Description"]}
  datasList={[
    [
      "amplification_count",
      "ushort or uint",
      "The number of output vertices produced for each vertex instance.",
    ],
    [
      "dispatch_quadgroups_per_threadgroup",
      "ushort or uint",
      "The quad-group execution width of a threadgroup specified at dispatch.",
    ],
    [
      "dispatch_simdgroups_per_threadgroup",
      "ushort or uint",
      "The SIMD-group execution width of a threadgroup specified at dispatch.",
    ],
    [
      "dispatch_threads_per_threadgroup",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The thread execution width of a threadgroup for threads specified at dispatch.",
    ],
    [
      "payload",
      "Pointer or l-value reference to User Defined T in object_data address space",
      "The payload is data passed to the mesh shader from the object shader. The payload pointer or reference is the same for all threads in the threadgroup. The payload memory is assumed uninitialized at the entry of the object function.",
    ],
    [
      "quadgroup_index_in_threadgroup",
      "ushort or uint",
      "The scalar index of a quad-group within a threadgroup.",
    ],
    [
      "quadgroups_per_threadgroup",
      "ushort or uint",
      "The quad-group execution width of a threadgroup.",
    ],
    [
      "simdgroup_index_in_threadgroup",
      "ushort or uint",
      "The scalar index of a SIMD-group within a threadgroup.",
    ],
    [
      "simdgroups_per_threadgroup",
      "ushort or uint",
      "The SIMD-group execution width of a threadgroup.",
    ],
    [
      "thread_index_in_quadgroup",
      "ushort or uint",
      "The scalar index of a thread within a quad-group.",
    ],
    [
      "thread_index_in_simdgroup",
      "ushort or uint",
      "The scalar index of a thread within a SIMD-group.",
    ],
    [
      "thread_index_in_threadgroup",
      "ushort or uint",
      "The scalar index of a thread within a threadgroup.",
    ],
    [
      "thread_position_in_grid",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The thread’s position in an N-dimensional grid of threads.",
    ],
    [
      "thread_position_in_threadgroup",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The thread’s unique position within a threadgroup",
    ],
    [
      "threadgroup_position_in_grid",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The threadgroup’s unique position within a grid.",
    ],
    [
      "threadgroups_per_grid",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The number of threadgroups in a grid.",
    ],
    [
      "threads_per_grid",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The grid size.",
    ],
    [
      "threads_per_simdgroup",
      "ushort or uint",
      "The thread execution width of a SIMD-group.",
    ],
    [
      "threads_per_threadgroup",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The thread execution width of a threadgroup.",
    ],
  ]}
/>

对象函数属性与内核函数属性具有相同的限制：

- 声明 `[[thread_position_in_grid]]`、`[[threads_per_grid]]`、`[[thread_position_in_threadgroup]]`、`[[threads_per_threadgroup]]`、`[[threadgroup_position_in_grid]]`、`[[dispatch_threads_per_threadgroup]]` 和 `[[threadgroups_per_grid]]` 的类型必须是标量类型或向量类型。如果它是向量类型，则用于声明这些参数的向量类型的组件数量需要匹配。
- 声明 `[[thread_position_in_grid]]` 和 `[[threads_per_grid]]` 的数据类型需要匹配。
- 声明 `[[thread_position_in_threadgroup]]`、`[[threads_per_threadgroup]]` 和 `[[dispatch_threads_per_threadgroup]]` 的数据类型需要匹配。
- 如果 `[[thread_position_in_threadgroup]]` 为 `uint`、`uint2` 或 `uint3` 类型，则 `[[thread_index_in_threadgroup]]` 需要为 `uint` 类型。
- 用于声明 `[[thread_index_in_simdgroup]]`、`[[threads_per_simdgroup]]`、`[[simdgroup_index_in_threadgroup]]`、`[[simdgroups_per_threadgroup]]`、`[[dispatch_simdgroups_per_threadgroup]]`、`[[quadgroup_index_in_threadgroup]]`、`[[quadgroups_per_threadgroup]]` 和 `[[的类型dispatch_quadgroups_per_threadgroup]]` 需要为 `ushort` 或 `uint`。声明这些内置变量的类型需要匹配。

### 网格函数输入属性

所有操作系统：自 Metal 3 起

所有操作系统：从 Metal 3.1 开始，全局变量现在可以指定这些属性，除非它们在动态库或单独编译的二进制函数中使用。

网格函数使用与内核函数相同的执行模型（请参阅第 5.2.3.6 节），它在 N 维线程网格上执行。网格函数参数可以来自 `samplers`、`textures`、`mesh<V, P, NV, NP, t>` 类型的参数以及 `device` 和 `constant` 的缓冲区。如果网格函数具有 `mesh<V, P, NV, NP,t>` 参数，则它指向表示要导出的网格的内存的不透明句柄。由 `mesh<V, P, NV, NP,t>` 参数引用的底层内存在给定线程组的线程之间共享。

网格函数支持内核函数内置属性的子集以及 `[[amplification_count]]`、`[[amplification_id]]` 和 `[[payload]]` 属性。`[[amplification_count]]` 和 `[[amplification_id]]` 的语义与第 5.2.3.1 节顶点函数输入属性中的相同。表 5.13 列出了可以为网格函数的参数指定的内置属性以及可以使用它们的相应数据类型。

从 Metal 3.1 开始，表 5.13 中的内置属性可以在程序范围变量上指定，但 `amplification_count`、`amplification_id` 和 `payload` 除外。

<TableView
  num="5.13"
  title="Attributes for Mesh Function"
  headers={["Attribute", "Corresponding Data Types", "Description"]}
  datasList={[
    [
      "amplification_count",
      "ushort or uint",
      "The number of output vertices produced for each primitive instance.",
    ],
    [
      "amplification_id",
      "ushort or uint",
      "The array index offset mappings for viewport and render target array indices, which enables routing an amplified vertex to a different viewport and render target.",
    ],
    [
      "dispatch_quadgroups_per_threadgroup",
      "ushort or uint",
      "The quad-group execution width of a threadgroup specified at dispatch.",
    ],
    [
      "dispatch_simdgroups_per_threadgroup",
      "ushort or uint",
      "The SIMD-group execution width of a threadgroup specified at dispatch.",
    ],
    [
      "dispatch_threads_per_threa dgroup",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The thread execution width of a threadgroup for threads specified at dispatch.",
    ],
    [
      "payload",
      "Pointer or l-value reference to User Defined T in object_data address space. Needs to be const qualified.",
      "The payload is data passed to the mesh shader from the object shader. The payload pointer or reference is the same for all threads in the mesh grid,. The payload memory is read-only in the mesh function.",
    ],
    [
      "quadgroup_index_in_threadg roup",
      "ushort or uint",
      "The scalar index of a quad-group within a threadgroup.",
    ],
    [
      "quadgroups_per_threadgroup",
      "ushort or uint",
      "The quad-group execution width of a threadgroup.",
    ],
    [
      "simdgroup_index_in_threadgroup",
      "ushort or uint",
      "The scalar index of a SIMD-group within a threadgroup.",
    ],
    [
      "simdgroups_per_threadgroup",
      "ushort or uint",
      "The SIMD-group execution width of a threadgroup.",
    ],
    [
      "thread_index_in_quadgroup",
      "ushort or uint",
      "The scalar index of a thread within a quad-group.",
    ],
    [
      "thread_index_in_simdgroup",
      "ushort or uint",
      "The scalar index of a thread within a SIMD-group.",
    ],
    [
      "thread_index_in_threadgrou p",
      "ushort or uint",
      "The scalar index of a thread within a threadgroup.",
    ],
    [
      "thread_position_in_grid",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The thread’s position in an N-dimensional grid of threads.",
    ],
    [
      "thread_position_in_threadg roup",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The thread’s unique position within a threadgroup",
    ],
    [
      "threadgroup_position_in_grid",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The threadgroup’s unique position within a grid.",
    ],
    [
      "threadgroups_per_grid",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The number of threadgroups in a grid.",
    ],
    [
      "threads_per_grid",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The grid size.",
    ],
    [
      "threads_per_simdgroup",
      "ushort or uint",
      "The thread execution width of a SIMD-group.",
    ],
    [
      "threads_per_threadgroup",
      "ushort, ushort2, ushort3, uint, uint2, or uint3",
      "The thread execution width of a threadgroup.",
    ],
  ]}
/>

网格函数属性与核函数属性具有相同的限制：

- 声明 `[[thread_position_in_grid]]`、`[[threads_per_grid]]`、`[[thread_position_in_threadgroup]]`、`[[threads_per_threadgroup]]`、`[[threadgroup_position_in_grid]]`、`[[dispatch_threads_per_threadgroup]]` 和 `[[threadgroups_per_grid]]` 的类型必须是标量类型或向量类型。如果它是向量类型，则用于声明这些参数的向量类型的组件数量需要匹配。
- 声明 `[[thread_position_in_grid]]` 和 `[[threads_per_grid]]` 的数据类型需要匹配。
- 声明 `[[thread_position_in_threadgroup]]`、`[[threads_per_threadgroup]]` 和 `[[dispatch_threads_per_threadgroup]]` 的数据类型需要匹配。
- 如果 `[[thread_position_in_threadgroup]]` 为 `uint`、`uint2` 或 `uint3` 类型，则 `[[thread_index_in_threadgroup]]` 需要为 `uint` 类型。
- 用于声明 `[[thread_index_in_simdgroup]]`、`[[threads_per_simdgroup]]`、`[[simdgroup_index_in_threadgroup]]`、`[[simdgroups_per_threadgroup]]`、`[[dispatch_simdgroups_per_threadgroup]]`、`[[quadgroup_index_in_threadgroup]]`、`[[quadgroups_per_threadgroup]]` 和 `[[的类型dispatch_quadgroups_per_threadgroup]]` 需要为 `ushort` 或 `uint`。声明这些内置变量的类型需要匹配。

## 输入组件属性

顶点函数输出和光栅化器生成的片段成为片段函数的每个片段输入。`[[stage_in]]` 属性可以组合每个片段的输入。

顶点函数可以通过使用顶点和实例 ID 作为参数传递给顶点函数的缓冲区进行索引来读取每个顶点的输入。要组装每个顶点的输入并将它们作为参数传递给顶点函数，请使用 `[[stage_in]]` 属性声明输入。

内核函数通过使用网格中的线程位置或线程组 ID 中的线程位置作为参数传递给内核函数的缓冲区或纹理进行索引来读取每个线程的输入。此外，要将每个线程输入作为参数传递给内核函数，请使用 `[[stage_in]]` 属性声明输入。

你只能使用 `[[stage_in]]` 属性声明顶点、片段或核函数的一个参数。对于使用 `[[stage_in]]` 属性声明的用户定义结构，该结构的成员可以是：

- 标量整数或浮点值。
- 整数或浮点值向量。
- 片段函数输入的 `interpolant<T,P>` 值。

不能使用 `stage_in` 属性来声明压缩向量、矩阵、结构、位域、类型引用或指针、标量、向量或矩阵数组的结构成员。

### 顶点函数输出示例

以下示例显示如何使用 `stage_in` 属性传递每个顶点的输入：

```cpp
struct VertexOutput {
    float4 position [[position]];
    float4 color;
    float2 texcoord;
};

struct VertexInput {
    float4 position [[attribute(0)]];
    float3 normal   [[attribute(1)]];
    half4 color     [[attribute(2)]];
    half2 texcoord  [[attribute(3)]];
};

constexpr constant uint MAX_LIGHTS = 4;

struct LightDesc {
    uint   num_lights;
    float4 light_position[MAX_LIGHTS];
    float4 light_color[MAX_LIGHTS];
    float4 light_attenuation_factors[MAX_LIGHTS];
};

constexpr sampler s = sampler(coord::normalized,
                              address::clamp_to_zero,
                              filter::linear);

vertex VertexOutput render_vertex(VertexInput v_in [[stage_in]],
                                  constant float4x4& mvp_matrix [[buffer(1)]],
                                  constant LightDesc& lights [[buffer(2)]],
                                  uint v_id [[vertex_id]]
) {
    VertexOutput v_out;
    v_out.position = v_in.position * mvp_matrix;
    v_out.color = do_lighting(v_in.position, v_in.normal, lights);
    ...
    return v_out;
}
```

### 片段函数输入示例

5.2.3.3 节中的示例之前介绍了 `process_vertex` 顶点函数，该函数为每个顶点返回一个 `VertexOutput` 结构。在以下示例中，`process_vertex` 的输出经过管道化，成为名为 `render_pixel` 的片段函数的输入，因此片段函数的第一个参数使用 `[[stage_in]]` 属性并使用传入的 `VertexOutput` 类型。（在 `render_pixel` 中，`imgA` 和 `imgB` 2D 纹理调用内置函数 `sample`，该函数在 6.12.3 节中介绍）。

```cpp
struct VertexOutput2 {
    float4 position [[position]];
    float4 color;
    float2 texcoord;
};

struct VertexInputData {
    float4 position;
    float3 normal;
    float2 texcoord;
};
```

### 内核函数每线程输入示例

以下示例演示如何使用 `stage_in` 属性传递每线程输入。内核函数中的 `stage_in` 属性允许你将用于声明函数中每线程输入的数据类型与用于存储每线程输入的实际数据类型解耦。

```cpp
struct PerThreadInput {
    float4 a [[attribute(0)]];
    float3 b [[attribute(1)]];
    half4 c  [[attribute(2)]];
    half2 d  [[attribute(3)]];
};

kernel void my_kernel(PerThreadInput thread_input [[stage_in]],
                      ...
                      uint t_id [[thread_position_in_grid]]
) {
    // ...
}
```
