# 标量和向量运算符

<ToBePolishedAfterTranslation />

<OrigninalPDF title="3.1 Scalar and Vector Operators" />

本节列出了二元和一元运算符，并描述了它们对标量和向量操作数的操作。

1. 算术二元运算符加 (`+`)、减 (`-`)、乘 (`*`) 和除 (`/`)，作用于标量和向量、整数和浮点数据类型操作数。在通常的算术转换之后，所有算术运算符都会返回与操作数类型相同的内置类型（整数或浮点）的结果。转换后，以下情况有效：

- 如果算术二元运算符的两个操作数为标量，则运算结果为标量。
- 如果一个操作数是标量，而另一个操作数是向量，
  - 标量将转换为向量操作数所使用的元素类型。
  - 然后标量类型被扩展为具有与向量操作数相同数量的分量的向量。
  - 该操作是按组件执行的，这会产生相同大小的向量。
- 如果两个操作数是相同大小的向量，则按分量执行运算，从而产生相同大小的向量。

对整数类型进行除法运算，如果结果超出整数类型的最大和最小可表示值的范围（例如有符号整数类型的 `TYPE_MIN/- 1` 或除以零），则不会导致异常，但会导致结果在一个未指定的值。根据 IEEE-754 的规定，浮点类型除以零会得到 `±∞` 或 `NaN`。（有关浮点运算的数值精度的更多信息，请参阅第 7 节。）

由于 `bfloat` 和 `half` 不能相互隐式转换，因此运算符不支持混合 `bfloat` 和 `half`。

2. 模运算符 (`%`) 作用于标量和向量整数数据类型操作数。在通常的算术转换之后，模运算符返回与操作数类型相同的内置类型的结果。以下情况有效：

- 如果模运算符的两个操作数是标量，则运算结果是标量。
- 如果一个操作数是标量，另一个操作数是向量：
  - 标量将转换为向量操作数的元素类型。
  - 然后标量类型被扩展为具有与向量操作数相同数量的分量的向量。
  - 该操作是按组件执行的，这会产生相同大小的向量。
- 如果两个操作数是相同大小的向量，则按分量执行运算，从而产生相同大小的向量。

对于使用第二个操作数为零计算的任何分量，模运算符结果是未定义的。如果一个或两个操作数均为负数，则结果未定义。具有非零操作数的其它组件的结果保持定义。

如果两个操作数都非负，则余数也非负。

3. 算术一元运算符（`+` 和 `-`）作用于标量和向量、整数和浮点类型操作数。

4. 算术后置和前置自增和自减运算符（`--` 和 `++`）具有标量和向量整数类型操作数。所有一元运算符都按组件方式处理其操作数。结果与操作数的类型相同。对于后置和前置递增和递减，表达式需要可分配给左值。预自增和预自减将其操作的表达式的内容加或减 1，预自增或预自减表达式的值就是该修改的结果值。后自增和后自减表达式将其操作的表达式的内容加或减 1，但结果表达式具有执行后自增或后自减之前表达式的值。

5. 关系运算符 \[大于(`>`)、小于(`<`)、大于或等于(`>=`)、小于或等于(`<=`)\] 作用于标量和向量、整数，和浮点型操作数。结果是布尔（`bool` 类型）标量或向量。转换操作数类型后，以下情况有效：

- 如果关系运算符的两个操作数都是标量，则运算结果为布尔值。
- 如果一个操作数是标量，另一个操作数是向量：
  - 标量将转换为向量操作数的元素类型。
  - 然后标量类型被扩展为具有与向量操作数相同数量的分量的向量。
  - 该操作按组件执行，生成布尔向量。
- 如果两个操作数是相同大小的向量，则按分量执行运算，从而产生相同大小的布尔向量。

如果任一参数为 `NaN`，则关系运算符返回 `false`。要测试向量的任何或所有元素上的关系运算，请在 `if(...)` 语句的上下文中使用 `any` 和 `all` 内置函数。（有关 `any` 和 `all` 函数的更多信息，请参阅第 6.4 节。） 6. 相等运算符，等于 (`==`) 和不等于 (`!=`)，作用于标量和向量、整数和浮点类型操作数。所有相等运算符都会生成布尔标量或向量。转换操作数类型后，以下情况有效：

- 如果相等运算符的两个操作数是标量，则运算结果是布尔值。
- 如果一个操作数是标量，另一个操作数是向量：
  - 标量将转换为向量操作数的元素类型。
  - 然后标量类型被扩展为具有与向量操作数相同数量的分量的向量。
  - 该操作按组件执行，生成布尔向量。
- 如果两个操作数是相同大小的向量，则按分量执行运算，从而产生相同大小的布尔向量。所有其它情况的隐式转换都是非法的。如果一个或两个参数均为 NaN，则等于运算符 equal (`==`) 返回 `false`。如果一个或两个参数均为 NaN，则等于运算符不等于 (`!=`) 返回 `true`。

7. 按位运算符 \[与(`&`)、或(`|`)、异或(`^`)、非(`~`)\] 可以作用于所有标量和向量内置类型操作数，除了内置标量和向量浮点操作数之外。

- 对于内置向量类型，按位运算符按组件应用。
- 如果一个操作数是标量，另一个操作数是向量，
  - 标量将转换为向量操作数使用的元素类型。
  - 然后标量类型被扩展为具有与向量操作数相同数量的分量的向量。
  - 按位运算按分量执行，产生相同大小的向量。

8. 逻辑运算符 \[and (`&&`) 或 (`||`)\] 作用于两个布尔表达式操作数。结果是标量或向量布尔值。

9. 逻辑一元运算符 not(`!`) 作用于一个布尔表达式操作数。结果是标量或向量布尔值。

10. 三元选择运算符 (`?:`) 作用于表达式 (`exp1?exp2:exp3`) 的三个操作数。该运算符计算第一个表达式 `exp1`，其结果必须是标量布尔值。如果结果为真，则计算第二个表达式；如果为 `false`，则计算第三个表达式。仅计算第二个和第三个表达式之一。第二个和第三个表达式可以是任何类型，如果：

- 第二个和第三个表达式的类型匹配，
- 或者对其中一个表达式进行类型转换，可以使其类型匹配（有关类型转换的更多信息，请参阅第 2.12 节），
- 或者一个表达式是向量，并且 other 是标量，标量可以扩展为与向量类型相同的类型。结果匹配类型是整个表达式的类型。

11. 补码运算符 (`~`) 作用于一个必须是标量或向量整数类型的操作数。结果是其操作数的补码。

右移 (`>>`) 和左移 (`<<`) 运算符作用于所有标量和向量整数类型操作数。对于内置向量类型，运算符按组件应用。对于右移 (`>>`) 和左移 (`<<`) 运算符，如果第一个操作数是标量，则最右边的操作数必须是标量。如果第一个操作数是向量，则最右边的操作数可以是向量或标量。`E1 << E2` 的结果是 `E1` 左移了 `E2` 中的 `log2(N)` 个最低有效位，被视为无符号整数值：

- 如果 `E1` 是标量，则 `N` 是用于表示 `E1` 数据类型的位数。
- 或者，如果 `E1` 是向量，则 `N` 是用于表示 `E1` 元素类型的位数。

对于左移运算符，空出的位用零填充。

`E1 >> E2` 的结果是 `E1` 右移了 `E2` 中的 `log2(N)` 个最低有效位，被视为无符号整数值：

- 如果 `E1` 是标量，则 `N` 是用于表示 `E1` 数据类型的位数。
- 或者，如果 `E1` 是向量，则 `N` 是用于表示 `E1` 元素的数据类型的位数。对于右移运算符，如果 `E1` 具有无符号类型或 `E1` 具有有符号类型和非负值，则空出的位将用零填充。如果 `E1` 具有有符号类型和负值，则空出的位将用 ones 填充（filled with ones）。

12. 赋值运算符的行为如 C++14 规范中所描述。对于 `lvalue = expression` 赋值操作，如果 `expression` 是标量类型且 `lvalue` 是向量类型，则标量将转换为向量操作数使用的元素类型。然后，标量类型被扩展为具有与向量操作数相同数量的分量的向量。该操作是按组件执行的，这会产生相同大小的向量。

上面未详细说明的其它 C++14 运算符（例如 `sizeof(T)`、一元 (`&`) 运算符和逗号 (`,`) 运算符）的行为如 C++14 规范中所述。

无符号整数应遵循模 `2n` 算术定律，其中 `n` 是该特定大小的整数的值表示中的位数。有符号整数溢出的结果是未定义的。

对于整数操作数，除法 (`/`) 运算符生成代数商，并丢弃任何小数部分（这通常称为向零截断）。如果商 `a/b` 可以用结果类型表示，则 `(a / b) * b + a % b` 等于 `a`。
