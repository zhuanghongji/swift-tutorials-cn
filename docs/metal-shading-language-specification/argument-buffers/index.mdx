## 2.13 参数缓冲区

所有操作系统：自 Metal 2 起支持参数缓冲区。

参数缓冲区扩展了基本缓冲区类型，包括指针（缓冲区）、纹理、纹理缓冲区和采样器。但是，参数缓冲区不能包含联合。以下示例为函数指定一个名为 Foo 的参数缓冲区结构：

struct Foo {texture2d a;深度 2d<浮点> b;采样器 c；纹理 2d<浮点> d;设备 float4\* e; texture2d<浮点> f; texture_buffer<浮点> g;整数 h； };内核 void my_kernel(constant Foo & f [[buffer(0)]]) {...}

||

可以使用现有的 array 模板类型来声明纹理和采样器数组。所有其他合法缓冲区类型的数组也可以使用 C 样式数组语法来声明。

参数缓冲区的成员可以分配一个通用的 [[id(n)]] 属性，其中 n 是一个 32 位无符号整数，可用于从 Metal API 中标识缓冲区元素。如果参数缓冲区包含缓冲区、纹理、采样器或任何具有 [[id]] 属性的元素，则可以将参数缓冲区与常规缓冲区区分开来。

同一索引不得分配给参数缓冲区的多个成员。手动分配的索引不需要是连续的，但它们必须单调递增。在以下示例中，索引 0 自动分配给 foo1。 [[id(n)]] 属性指定 t1 和 t2 结构成员的索引偏移量。由于 foo2 没有指定索引，因此会自动为其分配下一个索引 4，该索引是通过将前一个结构成员使用的最大 ID 加 1 来确定的。

struct Foo {texture2d t1 [[id(1)]]; texture2d<浮点> t2 [[id(3)]]; };结构体 Bar { Foo foo1; // foo1 分配了 idx 0，t1 和 t2 分配了 idx 1 和 3 Foo foo2; // foo2 分配了 idx 4，t1 和 t2 分配了 idx 5 和 7 };

如果省略 [[id]] 属性，则会根据以下规则自动分配 ID：

1. 将 ID 按顺序分配给结构成员，方法是将前一个结构成员使用的最大 ID 加 1。在下面的示例中，未提供索引，因此自动分配索引 0 和 1。 struct MaterialTexture {texture2d tex; // 分配索引 0 float4 uvScaleOffset; // 分配索引 1 }; 2. 通过将前一个数组元素使用的最大 ID 加 1，将 ID 按顺序分配给数组元素。在下面的示例中，索引 1 - 3 自动分配给 texs1 的三个数组元素。索引 4 - 5 自动分配给材料[0] 中的字段，索引 6 - 7 分配给材料[1]，索引 8 - 9 分配给材料[2]。 [[id(20)]] 属性首先将索引 20 分配给常量。结构材质 { float4 漫反射; // 分配索引 0 array, 3> texs1; // 指定索引 1 - 3 MaterialTexture 材料[3]; // 分配索引 4 - 9 int 常量 [[id(20)]] [4]; // 分配索引 20 - 23 };

||

3. 如果结构体成员或数组元素 E 本身是一个结构体或数组，则从分配给 E 的 ID 开始，按照规则 1 和 2 递归为其结构体成员或数组元素分配索引。在以下示例中，索引 4 为显式提供给称为“法线”的嵌套结构，因此其元素（之前定义为 tex 和 uvScaleOffset）分别分配 ID 4 和 5。通过在前一个成员使用的最大 ID (5) 上加 1，为称为镜面反射的嵌套结构的元素分配 ID 6 和 7。结构材质 { MaterialTexture 漫反射; // 分配索引 0, 1 MaterialTexture 法线 [[id(4)]];// 分配索引 4, 5 MaterialTexture 镜面反射; // 分配索引 6, 7 } 4. 根据前面的三个规则，顶级参数缓冲区参数被分配从 0 开始的 ID。

## 2.13.1 对参数缓冲区的第 2 层硬件支持

对于第 2 层硬件，参数缓冲区具有以下第 1 层硬件所不具备的附加功能。

你可以通过指针索引访问参数缓冲区。下面显示的语法引用了一组连续的、独立编码的参数缓冲区：

内核 void kern(常量资源 \*resArray [[buffer(0)]]) { 常量资源 &resources = resArray[3]; }

struct TStruct {texture2d tex; };内核 void kern(constant TStruct \*textures [[buffer(0)]]);

为了支持 GPU 驱动的管道以及间接绘制调用和分派，你可以在函数内的结构和数组之间复制资源，如下所示：

kernel void copy(constant Foo & src [[buffer(0)]], device Foo & dst [[buffer(1)]]) { dst.a = src.d; ... }

||

采样器无法从线程地址空间复制到设备地址空间。因此，采样器只能直接从另一个参数缓冲区复制到一个参数缓冲区中。下面的示例显示了合法复制和非法复制：

结构资源 { 采样器 sam; };内核无效复制（设备资源* src，设备资源* dst，采样器 sam1）{ constexpr 采样器 sam2; dst->sam = src->sam; // 合法: device -> device dst->sam = sam1; // 非法：线程 -> 设备 dst->sam = sam2; // 非法：线程 -> 设备 }

参数缓冲区可以包含指向其他参数缓冲区的指针：

结构纹理 {texture2d 漫反射; texture2d 镜面反射； }; struct Material { 设备纹理 \*textures; };片段 float4 fragFunc(设备材质&材质);
