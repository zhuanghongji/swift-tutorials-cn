# 声明

<ToBePolishedAfterTranslation />

<OriginalSource
  title="Declarations"
  url="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/declarations"
  summary="介绍类型、运算符、变量和其它名称和结构"
/>

声明在你的程序中引入了一个新名称或结构。例如，你使用声明来引入函数和方法，引入变量和常量，以及定义枚举、结构、类和协议类型。你还可以使用声明来扩展现有命名类型的行为，并将在别处声明的符号导入到你的程序中。

在 Swift 中，大多数声明也是定义，因为它们在声明的同时被实现或初始化。也就是说，因为协议不实现它们的成员，所以大多数协议成员只是声明。为方便起见，也因为区别在 Swift 中并不那么重要，术语声明涵盖了声明和定义。

:::note 声明的语法

```
declaration → import-declaration

declaration → constant-declaration

declaration → variable-declaration

declaration → typealias-declaration

declaration → function-declaration

declaration → enum-declaration

declaration → struct-declaration

declaration → class-declaration

declaration → actor-declaration

declaration → protocol-declaration

declaration → initializer-declaration

declaration → deinitializer-declaration

declaration → extension-declaration

declaration → subscript-declaration

declaration → operator-declaration

declaration → precedence-group-declaration

declarations → declaration declarations?
```

:::

## 顶层代码

Swift 源文件中的顶级代码由零个或多个语句、声明和表达式组成。默认情况下，在源文件的顶层声明的变量、常量和其它命名声明可供属于同一模块的每个源文件中的代码访问。你可以通过使用访问级别修饰器标记声明来覆盖此默认行为，如访问控制级别中所述。

有两种顶层代码：顶层声明和可执行顶层代码。顶级声明仅包含声明，并且在所有 Swift 源文件中都允许使用。可执行的顶级代码包含语句和表达式，而不仅仅是声明，并且只允许作为程序的顶级入口点。

你编译成可执行文件的 Swift 代码最多可以包含以下方法之一来标记顶级入口点，无论代码如何组织到文件和模块中：属性，属性 main，属性，文件，或包含顶级可执行代码的文件。NSApplicationMainUIApplicationMainmain.swift

:::note 顶级声明的语法

```
top-level-declaration → statements?
```

:::

## 代码块

各种声明和控制结构使用代码块将语句组合在一起。它具有以下形式：

```swift
{
   <#statements#>
}
```

代码块中的语句包括声明、表达式和其它类型的语句，并按照它们在源代码中出现的顺序执行。

:::note 代码块语法

```
code-block → { statements? }
```

:::

## 进口报关

导入声明允许你访问在当前文件外部声明的符号。基本形式导入整个模块；它由 import 关键字和模块名称组成：

```swift
import <#module#>
```

提供更多细节限制导入哪些符号——你可以指定特定的子模块或模块或子模块中的特定声明。当使用这种详细形式时，只有导入的符号（而不是声明它的模块）在当前范围内可用。

```swift
import <#import kind#> <#module#>.<#symbol name#>
import <#module#>.<#submodule#>
```

:::note 进口申报的语法

```
import-declaration → attributes? import import-kind? import-path

import-kind → typealias | struct | class | enum | protocol | let | var | func

import-path → identifier | identifier . import-path
```

:::

## 常量声明

常量声明将常量命名值引入到你的程序中。常量声明使用 let 关键字声明并具有以下形式：

```swift
let <#constant name#>: <#type#> = <#expression#>
```

常量声明定义了常量名称和初始化表达式值之间的不可变绑定；常量的值一旦设置，就不能再改变。也就是说，如果用类对象初始化常量，则对象本身可以更改，但常量名称与其引用的对象之间的绑定不能。

当在全局范围内声明常量时，必须用一个值对其进行初始化。当一个常量声明出现在一个函数或方法的上下文中时，它可以稍后被初始化，只要它保证在第一次读取它的值之前设置一个值。如果编译器可以证明常量的值从未被读取过，则常量根本不需要设置值。当常量声明出现在类或结构声明的上下文中时，它被视为常量属性。常量声明不是计算属性，因此没有 getter 或 setter。

如果常量声明的常量名称是元组模式，则元组中每一项的名称都绑定到初始化表达式中的相应值。

```swift
let (firstNumber, secondNumber) = (10, 42)
```

在此示例中，是 value 的命名常量，是 value 的命名常量。这两个常量现在可以独立使用：firstNumber10secondNumber42

```swift
print("The first number is \(firstNumber).")
// Prints "The first number is 10."
print("The second number is \(secondNumber).")
// Prints "The second number is 42."
```

当可以推断常量名称的类型时，类型注释 ( : type ) 在常量声明中是可选的，如类型推断中所述。

static 要声明常量类型属性，请使用声明修饰器标记声明。类的常量类型属性总是隐式最终的；你不能使用 classorfinal 声明修饰器来标记它以允许或禁止子类覆盖。类型属性在类型属性中讨论。

有关常量的更多信息以及何时使用它们的指导，请参阅常量和变量以及存储的属性。

:::note 常量声明的语法

```
constant-declaration → attributes? declaration-modifiers? let pattern-initializer-list

pattern-initializer-list → pattern-initializer | pattern-initializer , pattern-initializer-list

pattern-initializer → pattern initializer?

initializer → = expression
```

:::

## 变量声明

变量声明将一个名为 value 的变量引入到你的程序中，并使用 var 关键字进行声明。

变量声明有多种形式来声明不同类型的命名可变值，包括存储和计算变量和属性、存储变量和属性观察器以及静态变量属性。要使用的适当形式取决于声明变量的范围和你打算声明的变量类型。

:::note
你还可以在协议声明的上下文中声明属性，如协议属性声明中所述。
:::

你可以通过使用声明修饰器标记子类的属性声明来覆盖子类中的属性 override，如覆盖中所述。

## 存储变量和存储变量属性

以下形式声明了一个存储变量或存储变量属性：

```swift
var <#variable name#>: <#type#> = <#expression#>
```

你可以在全局范围、函数的局部范围或类或结构声明的上下文中定义这种形式的变量声明。当在全局范围或函数的局部范围内声明这种形式的变量声明时，它被称为存储变量。当它在类或结构声明的上下文中声明时，它被称为存储变量属性。

初始化表达式不能出现在协议声明中，但在所有其它上下文中，初始化表达式是可选的。也就是说，如果不存在初始化表达式，则变量声明必须包含显式类型注释 ( : type )。

与常量声明一样，如果变量名称是元组模式，则元组中每个项目的名称都绑定到初始化表达式中的相应值。

顾名思义，存储变量或存储变量属性的值存储在内存中。

## 计算变量和计算属性

以下形式声明计算变量或计算属性：

```swift
var <#variable name#>: <#type#> {
   get {
      <#statements#>
   }
   set(<#setter name#>) {
      <#statements#>
   }
}
```

你可以在全局范围、函数的局部范围或类、结构、枚举或扩展声明的上下文中定义这种形式的变量声明。当在全局范围或函数的局部范围内声明这种形式的变量声明时，它被称为计算变量。当它在类、结构或扩展声明的上下文中声明时，它被称为计算属性。

getter 用于读取值，setter 用于写入值。setter 子句是可选的，当只需要 getter 时，你可以省略这两个子句并直接返回请求的值，如只读计算属性中所述。但是，如果你提供了 setter 子句，则还必须提供 getter 子句。

setter 名称和括号是可选的。如果你提供设置器名称，它将用作设置器的参数名称。如果你不提供设置器名称，则设置器的默认参数名称是，如速记设置器声明中所述。newValue

与存储命名值和存储变量属性不同，计算命名值或计算属性的值不存储在内存中。

有关更多信息和查看计算属性的示例，请参阅计算属性。

## 存储变量观察者和属性观察者

你还可以使用和观察者声明存储的变量或属性。用观察者声明的存储变量或属性具有以下形式：willSetdidSet

```swift
var <#variable name#>: <#type#> = <#expression#> {
   willSet(<#setter name#>) {
      <#statements#>
   }
   didSet(<#setter name#>) {
      <#statements#>
   }
}
```

你可以在全局范围、函数的局部范围或类或结构声明的上下文中定义这种形式的变量声明。当在全局范围或函数的局部范围内声明这种形式的变量声明时，观察者称为存储变量观察者。当它在类或结构声明的上下文中声明时，观察者称为属性观察者。

你可以将属性观察器添加到任何存储的属性。你还可以通过覆盖子类中的属性，将属性观察器添加到任何继承的属性（无论是存储的还是计算的），如覆盖属性观察器中所述。

初始化表达式在类或结构声明的上下文中是可选的，但在其它地方是必需的。当可以从初始化表达式中推断出类型时，类型注释是可选的。第一次读取属性值时会计算此表达式。如果你在不读取属性的情况下覆盖它的初始值，则在你第一次写入该属性之前会对该表达式求值。

当设置变量或属性的值时，和观察者提供了一种观察（并做出适当响应）的方法。首次初始化变量或属性时，不会调用观察者。相反，只有在初始化上下文之外设置值时才会调用它们。willSetdidSet

在设置变量或属性的值之前调用观察者。新值作为常量传递给观察者，因此在子句的实现中不能更改。设置新值后立即调用观察者。与观察者相反，变量或属性的旧值被传递给观察者，以防你仍然需要访问它。也就是说，如果你在其自己的观察者子句中为变量或属性赋值，则你赋值的新值将替换刚刚设置并传递给观察者的值。willSetwillSetwillSetdidSetwillSetdidSetdidSetwillSet

and 子句中的 setter 名称和括号是可选的。如果你提供 setter 名称，它们将用作和观察者的参数名称。如果你不提供 setter 名称，则观察者的默认参数名称为，观察者的默认参数名称为.willSetdidSetwillSetdidSetwillSetnewValuedidSetoldValue

当你提供子句时，该子句是可选的。同样，当你提供子句时，该子句是可选的。didSetwillSetwillSetdidSet

如果观察者的主体引用旧值，则在观察者之前调用 getter，以使旧值可用。否则，将存储新值而不调用超类的 getter。下面的示例显示了一个由超类定义并被其子类覆盖以添加观察者的计算属性。didSet

```swift
class Superclass {
    private var xValue = 12
    var x: Int {
        get { print("Getter was called"); return xValue }
        set { print("Setter was called"); xValue = newValue }
    }
}

// This subclass doesn't refer to oldValue in its observer, so the
// superclass's getter is called only once to print the value.
class New: Superclass {
    override var x: Int {
        didSet { print("New value \(x)") }
    }
}
let new = New()
new.x = 100
// Prints "Setter was called"
// Prints "Getter was called"
// Prints "New value 100"

// This subclass refers to oldValue in its observer, so the superclass's
// getter is called once before the setter, and again to print the value.
class NewAndOld: Superclass {
    override var x: Int {
        didSet { print("Old value \(oldValue) - new value \(x)") }
    }
}
let newAndOld = NewAndOld()
newAndOld.x = 200
// Prints "Getter was called"
// Prints "Setter was called"
// Prints "Getter was called"
// Prints "Old value 12 - new value 200"
```

有关更多信息和查看如何使用属性观察器的示例，请参阅属性观察器。

## 类型变量属性

static 要声明类型变量属性，请使用声明修饰器标记声明。类可以使用声明修饰器标记类型计算属性，class 而不是允许子类覆盖超类的实现。类型属性在类型属性中讨论。

:::note 变量声明的语法

```
variable-declaration → variable-declaration-head pattern-initializer-list

variable-declaration → variable-declaration-head variable-name type-annotation code-block

variable-declaration → variable-declaration-head variable-name type-annotation getter-setter-block

variable-declaration → variable-declaration-head variable-name type-annotation getter-setter-keyword-block

variable-declaration → variable-declaration-head variable-name initializer willSet-didSet-block

variable-declaration → variable-declaration-head variable-name type-annotation initializer? willSet-didSet-block

variable-declaration-head → attributes? declaration-modifiers? var

variable-name → identifier

getter-setter-block → code-block

getter-setter-block → { getter-clause setter-clause? }

getter-setter-block → { setter-clause getter-clause }

getter-clause → attributes? mutation-modifier? get code-block

setter-clause → attributes? mutation-modifier? set setter-name? code-block

setter-name → ( identifier )

getter-setter-keyword-block → { getter-keyword-clause setter-keyword-clause? }

getter-setter-keyword-block → { setter-keyword-clause getter-keyword-clause }

getter-keyword-clause → attributes? mutation-modifier? get

setter-keyword-clause → attributes? mutation-modifier? set

willSet-didSet-block → { willSet-clause didSet-clause? }

willSet-didSet-block → { didSet-clause willSet-clause? }

willSet-clause → attributes? willSet setter-name? code-block

didSet-clause → attributes? didSet setter-name? code-block
```

:::

## 类型别名声明

类型别名声明将现有类型的命名别名引入到你的程序中。类型别名声明使用 typealias 关键字声明并具有以下形式：

```swift
typealias <#name#> = <#existing type#>
```

声明类型别名后，可以在程序的任何地方使用别名代替现有类型。现有类型可以是命名类型或复合类型。类型别名不会创建新类型；它们只是允许名称引用现有类型。

类型别名声明可以使用泛型参数为现有泛型类型命名。类型别名可以为现有类型的部分或全部泛型参数提供具体类型。例如：

```swift
typealias StringDictionary<Value> = Dictionary<String, Value>

// The following dictionaries have the same type.
var dictionary1: StringDictionary<Int> = [:]
var dictionary2: Dictionary<String, Int> = [:]
```

当使用泛型参数声明类型别名时，这些参数的约束必须与现有类型的泛型参数的约束完全匹配。例如：

```swift
typealias DictionaryOfInts<Key: Hashable> = Dictionary<Key, Int>
```

因为类型别名和现有类型可以互换使用，所以类型别名不能引入额外的泛型约束。

类型别名可以通过从声明中省略所有泛型参数来转发现有类型的泛型参数。例如，Diccionario 此处声明的类型别名与 Dictionary.

```swift
typealias Diccionario = Dictionary
```

在协议声明中，类型别名可以为经常使用的类型提供更短、更方便的名称。例如：

```swift
protocol Sequence {
    associatedtype Iterator: IteratorProtocol
    typealias Element = Iterator.Element
}

func sum<T: Sequence>(_ sequence: T) -> Int where T.Element == Int {
    // ...
}
```

如果没有此类型别名，该 sum 函数将不得不引用关联类型而不是.T.Iterator.ElementT.Element

另请参阅协议关联类型声明。

:::note 类型别名声明的语法

```
typealias-declaration → attributes? access-level-modifier? typealias typealias-name generic-parameter-clause? typealias-assignment

typealias-name → identifier

typealias-assignment → = type
```

:::

## 函数声明

函数声明将函数或方法引入到你的程序中。在类、结构、枚举或协议的上下文中声明的函数称为方法。函数声明使用关键字声明 func，并具有以下形式：

```swift
func <#function name#>(<#parameters#>) -> <#return type#> {
   <#statements#>
}
```

如果函数的返回类型为 Void，则可以省略返回类型，如下所示：

```swift
func <#function name#>(<#parameters#>) {
   <#statements#>
}
```

必须包括每个参数的类型——无法推断。如果你写 inout 在参数的类型前面，参数可以在函数的范围内被修改。在下面的 In-Out Parameters 中详细讨论了 In-out 参数。

其语句仅包含单个表达式的函数声明被理解为返回该表达式的值。只有当表达式的类型和函数的返回类型不是 Void 并且不是像 Never 这样没有任何情况的枚举时，才会考虑这种隐式返回语法。

函数可以使用元组类型作为函数的返回类型来返回多个值。

函数定义可以出现在另一个函数声明中。这种函数称为嵌套函数。

如果嵌套函数捕获保证永远不会转义的值（例如输入输出参数）或作为非转义函数参数传递，则它是非转义的。否则，嵌套函数是转义函数。

有关嵌套函数的讨论，请参阅嵌套函数。

## 参数名称

函数参数是一个以逗号分隔的列表，其中每个参数都具有多种形式之一。函数调用中参数的顺序必须与函数声明中参数的顺序相匹配。参数列表中最简单的条目具有以下形式：

```
<#parameter name#>: <#parameter type#>
```

参数有一个在函数体内使用的名称，以及一个在调用函数或方法时使用的参数标签。默认情况下，参数名称也用作参数标签。例如：

```swift
func f(x: Int, y: Int) -> Int { return x + y }
f(x: 1, y: 2) // both x and y are labeled
```

你可以使用以下形式之一覆盖参数标签的默认行为：

```swift
<#argument label#> <#parameter name#>: <#parameter type#>
_ <#parameter name#>: <#parameter type#>
```

参数名称之前的名称为参数提供了一个显式参数标签，该标签可以与参数名称不同。相应的参数必须在函数或方法调用中使用给定的参数标签。

参数名称前的下划线 ( \_) 会抑制参数标签。相应的参数在函数或方法调用中必须没有标签。

```swift
func repeatGreeting(_ greeting: String, count n: Int) { /* Greet n times */ }
repeatGreeting("Hello, world!", count: 2) //  count is labeled, greeting is not
```

## 输入输出参数

in-out 参数传递如下：

1. 当函数被调用时，参数的值被复制。
2. 在函数体中，副本被修改。
3. 当函数返回时，副本的值被分配给原始参数。

此行为称为复制输入复制输出或按值调用结果。例如，当计算属性或具有观察者的属性作为输入输出参数传递时，它的 getter 作为函数调用的一部分被调用，它的 setter 作为函数返回的一部分被调用。

作为一种优化，当参数是存储在内存中物理地址的值时，函数体内部和外部都使用相同的内存位置。优化后的行为称为按引用调用；它满足了复制输入复制输出模型的所有要求，同时消除了复制的开销。使用复制输入复制输出给出的模型编写你的代码，而不依赖于按引用调用优化，以便它在有或没有优化的情况下都能正确运行。

在函数内，不要访问作为输入输出参数传递的值，即使原始值在当前范围内可用。访问原始值是同时访问值，这违反了 Swift 的内存独占性保证。出于同样的原因，你不能将相同的值传递给多个 in-out 参数。

有关内存安全和内存独占性的更多信息，请参阅内存安全。

捕获输入输出参数的闭包或嵌套函数必须是非转义的。如果你需要捕获输入输出参数而不改变它，请使用捕获列表以不可变的方式显式捕获参数。

```swift
func someFunction(a: inout Int) -> () -> Int {
    return { [a] in return a + 1 }
}
```

如果你需要捕获和改变输入输出参数，请使用显式本地副本，例如在多线程代码中确保在函数返回之前完成所有改变。

```swift
func multithreadedFunction(queue: DispatchQueue, x: inout Int) {
    // Make a local copy and manually copy it back.
    var localX = x
    defer { x = localX }

    // Operate on localX asynchronously, then wait before returning.
    queue.async { someMutatingOperation(&localX) }
    queue.sync {}
}
```

有关输入输出参数的更多讨论和示例，请参阅输入输出参数。

## 特殊类型的参数

可以忽略参数，采用可变数量的值，并使用以下形式提供默认值：

```swift
_ : <#parameter type#>
<#parameter name#>: <#parameter type#>...
<#parameter name#>: <#parameter type#> = <#default argument value#>
```

下划线 ( \_) 参数被显式忽略，并且无法在函数体内访问。

具有基本类型名称后紧跟三个点 ( ...) 的参数被理解为可变参数。紧跟可变参数的参数必须有一个参数标签。一个函数可以有多个可变参数。可变参数被视为包含基本类型名称元素的数组。例如，可变参数 Int...被视为 `[Int]`. 有关使用可变参数的示例，请参阅可变参数。

带有等号 ( =) 和其类型后的表达式的参数被理解为具有给定表达式的默认值。调用函数时会评估给定的表达式。如果在调用函数时省略参数，则使用默认值代替。

```swift
func f(x: Int = 42) -> Int { return x }
f()       // Valid, uses default value
f(x: 7)   // Valid, uses the value provided
f(7)      // Invalid, missing argument label
```

## 特殊方法

枚举或结构上修改的方法 self 必须用声明修饰器标记 mutating。

覆盖超类方法的方法必须用 override 声明修饰器标记。在没有修饰器的情况下重写方法或在未重写超类方法的方法上 override 使用修饰器是编译时错误。override

与类型而不是类型实例相关联的方法必须用 static 枚举和结构的声明修饰器标记，或者用类 static 的或 class 声明修饰器标记。用声明修饰器标记的类类型方法 class 可以被子类实现覆盖；class final 标有或 static 不能被覆盖的类类型方法。

## 具有特殊名称的方法

几个具有特殊名称的方法为函数调用语法启用语法糖。如果类型定义了这些方法之一，则可以在函数调用语法中使用该类型的实例。函数调用被理解为对该实例上特别命名的方法之一的调用。

类、结构或枚举类型可以通过定义方法或方法来支持函数调用语法，如 dynamicCallable 中所述，或通过定义调用函数方法，如下所述。如果该类型同时定义了函数调用方法和属性使用的方法之一，则在可以使用任一方法的情况下，编译器会优先选择函数调用方法。dynamicallyCall(withArguments:)dynamicallyCall(withKeywordArguments:)dynamicCallable

call-as-function 方法的名称是，或者另一个以开头并添加标记或未标记参数的名称——例如，也是有效的 call-as-function 方法名称。callAsFunction()callAsFunction(callAsFunction(_:_:)callAsFunction(something:)

以下函数调用是等效的：

```swift
struct CallableStruct {
    var value: Int
    func callAsFunction(_ number: Int, scale: Int) {
        print(scale * (number + value))
    }
}
let callable = CallableStruct(value: 100)
callable(4, scale: 2)
callable.callAsFunction(4, scale: 2)
// Both function calls print 208.
```

作为函数调用的方法和来自属性的方法在你编码到类型系统中的信息量与运行时可能的动态行为量之间做出不同的权衡。当你声明一个函数调用方法时，你指定了参数的数量，以及每个参数的类型和标签。属性的方法仅指定用于保存参数数组的类型。dynamicCallabledynamicCallable

定义函数调用方法或属性中的方法不允许你使用该类型的实例，就好像它是函数调用表达式以外的任何上下文中的函数一样。例如：dynamicCallable

```swift
let someFunction1: (Int, Int) -> Void = callable(_:scale:)  // Error
let someFunction2: (Int, Int) -> Void = callable.callAsFunction(_:scale:)
```

下标为成员查找启用语法糖，如 dynamicMemberLookup 中所述。subscript(dynamicMember:)

## 投掷函数和方法

可以抛出错误的函数和方法必须用 throws 关键字标记。这些函数和方法被称为抛出函数和抛出方法。它们具有以下形式：

```swift
func <#function name#>(<#parameters#>) throws -> <#return type#> {
   <#statements#>
}
```

对抛出函数或方法的调用必须包装在 tryor 表达式中（即，在 or 运算符 try!的范围内）。trytry!

关键字 throws 是函数类型的一部分，非抛出函数是抛出函数的子类型。因此，你可以在期望抛出函数的上下文中使用非抛出函数。

你不能仅根据函数是否会抛出错误来重载函数。也就是说，你可以根据函数参数是否可以抛出错误来重载函数。

throwing 方法不能覆盖 nonthrowing 方法，throwing 方法不能满足 nonthrowing 方法的协议要求。也就是说，非抛出方法可以覆盖抛出方法，非抛出方法可以满足抛出方法的协议要求。

## 重新抛出函数和方法

一个函数或方法可以用关键字来声明 rethrows，以指示它仅在其函数参数之一抛出错误时抛出错误。这些函数和方法称为重新抛出函数和重新抛出方法。重新抛出函数和方法必须至少有一个抛出函数参数。

```swift
func someFunction(callback: () throws -> Void) rethrows {
    try callback()
}
```

重新抛出的函数或方法 throw 只能在 catch 子句中包含语句。do 这使你可以在-语句中调用 throwing 函数 catch，并 catch 通过抛出不同的错误来处理子句中的错误。此外，该 catch 子句必须只处理由重新抛出函数的抛出参数之一抛出的错误。例如，以下是无效的，因为该 catch 子句将处理由 抛出的错误。alwaysThrows()

```swift
func alwaysThrows() throws {
    throw SomeError.error
}
func someFunction(callback: () throws -> Void) rethrows {
    do {
        try callback()
        try alwaysThrows()  // Invalid, alwaysThrows() isn't a throwing parameter
    } catch {
        throw AnotherError.error
    }
}
```

抛出方法不能重写重新抛出方法，并且抛出方法不能满足重新抛出方法的协议要求。也就是说，重新抛出方法可以覆盖抛出方法，重新抛出方法可以满足抛出方法的协议要求。

## 异步函数和方法

异步运行的函数和方法必须用 async 关键字标记。这些函数和方法称为异步函数和异步方法。它们具有以下形式：

```swift
func <#function name#>(<#parameters#>) async -> <#return type#> {
   <#statements#>
}
```

对异步函数或方法的调用必须包含在表达式中 await——也就是说，它们必须在 await 运算符的范围内。

关键字 async 是函数类型的一部分，同步函数是异步函数的子类型。因此，你可以在需要异步函数的上下文中使用同步函数。例如，你可以用同步方法覆盖异步方法，同步方法可以满足需要异步方法的协议要求。

你可以根据函数是否异步来重载函数。在调用点，上下文决定使用哪个重载：在异步上下文中，使用异步函数，在同步上下文中，使用同步函数。

异步方法不能覆盖同步方法，异步方法不能满足同步方法的协议要求。也就是说，同步方法可以覆盖异步方法，同步方法可以满足异步方法的协议要求。

## 永不返回的函数

Swift 定义了一个 Never 类型，它表示一个函数或方法不会返回给它的调用者。具有返回类型的函数和方法 Never 称为 nonreturning。非返回函数和方法要么导致不可恢复的错误，要么开始无限期继续的一系列工作。这意味着永远不会执行调用后立即运行的代码。抛出和重新抛出函数可以将程序控制转移到适当的 catch 块，即使它们是不返回的。

可以调用非返回函数或方法来结束 elseguard 语句的子句，如 Guard Statement 中所述。

你可以覆盖非返回方法，但新方法必须保留其返回类型和非返回行为。

:::note 函数声明的语法

```
function-declaration → function-head function-name generic-parameter-clause? function-signature generic-where-clause? function-body?

function-head → attributes? declaration-modifiers? func

function-name → identifier | operator

function-signature → parameter-clause async? throws? function-result?

function-signature → parameter-clause async? rethrows function-result?

function-result → -> attributes? type

function-body → code-block

parameter-clause → ( ) | ( parameter-list )

parameter-list → parameter | parameter , parameter-list

parameter → external-parameter-name? local-parameter-name type-annotation default-argument-clause?

parameter → external-parameter-name? local-parameter-name type-annotation

parameter → external-parameter-name? local-parameter-name type-annotation ...

external-parameter-name → identifier

local-parameter-name → identifier

default-argument-clause → = expression
```

:::

## 枚举声明

枚举声明将命名的枚举类型引入到你的程序中。

枚举声明有两种基本形式，使用 enum 关键字声明。使用任一形式声明的枚举的主体包含零个或多个值（称为枚举案例）和任意数量的声明，包括计算属性、实例方法、类型方法、初始化器、类型别名，甚至其它枚举、结构、类和演员声明。枚举声明不能包含析构器或协议声明。

枚举类型可以采用任意数量的协议，但不能从类、结构或其它枚举继承。

与类和结构不同，枚举类型没有隐式提供的默认初始化器；所有初始化器都必须显式声明。初始化器可以委托给枚举中的其它初始化器，但只有在初始化器将其中一个枚举情况分配给 后，初始化过程才算完成 self。

与结构相似但与类不同的是，枚举是值类型；枚举的实例在分配给变量或常量时，或者在作为参数传递给函数调用时被复制。有关值类型的信息，请参阅结构和枚举是值类型。

你可以使用扩展声明来扩展枚举类型的行为，如扩展声明中所述。

包含任何类型个案的枚举
以下形式声明一个枚举类型，其中包含任何类型的枚举案例：

```swift
enum <#enumeration name#>: <#adopted protocols#> {
    case <#enumeration case 1#>
    case <#enumeration case 2#>(<#associated value types#>)
}
```

以这种形式声明的枚举有时在其它编程语言中称为可区分联合。

在这种形式中，每个 case 块由 case 关键字和一个或多个枚举 case 组成，以逗号分隔。每个案例的名称必须是唯一的。每个案例还可以指定它存储给定类型的值。这些类型在关联的值类型元组中指定，紧跟在案例名称之后。

存储关联值的枚举案例可以用作创建具有指定关联值的枚举实例的函数。就像函数一样，你可以获得对枚举案例的引用并稍后在你的代码中应用它。

```swift
enum Number {
    case integer(Int)
    case real(Double)
}
let f = Number.integer
// f is a function of type (Int) -> Number

// Apply f to create an array of Number instances with integer values
let evenInts: [Number] = [0, 2, 4, 6].map(f)
```

有关更多信息和查看具有关联值类型的事例示例，请参阅关联值。

## 间接枚举

枚举可以有一个递归结构，也就是说，它们可以有关联值的情况，这些值是枚举类型本身的实例。但是，枚举类型的实例具有值语义，这意味着它们在内存中具有固定的布局。为了支持递归，编译器必须插入一个间接层。

要为特定枚举案例启用间接，请使用 indirect 声明修饰器对其进行标记。间接案例必须具有关联值。

```swift
enum Tree<T> {
    case empty
    indirect case node(value: T, left: Tree, right: Tree)
}
```

要为具有关联值的枚举的所有情况启用间接，请使用修饰器标记整个枚举 indirect- 当枚举包含许多需要使用修饰器标记的情况时，这很方便 indirect。

用修饰器标记的枚举 indirect 可以包含具有关联值的案例和没有关联值的案例的混合。也就是说，它不能包含任何也标有修饰器的案例 indirect。

具有原始值类型个案的枚举
以下形式声明了一个枚举类型，其中包含相同基本类型的枚举情况：

```swift
enum <#enumeration name#>: <#raw-value type#>, <#adopted protocols#> {
    case <#enumeration case 1#> = <#raw value 1#>
    case <#enumeration case 2#> = <#raw value 2#>
}
```

在这种形式中，每个 case 块由关键字组成 case，后跟一个或多个枚举 case，用逗号分隔。与第一种形式的案例不同，每个案例都有一个基础值，称为原始值，具有相同的基本类型。这些值的类型在原始值类型中指定，并且必须表示整数、浮点数、字符串或单个字符。特别是，原始值类型必须符合 Equatable 协议和以下协议之一：对于整数文字，对于浮点文字，对于包含任意数量字符的字符串文字，和或 ExpressibleByIntegerLiteralExpressibleByFloatLiteralExpressibleByStringLiteralExpressibleByUnicodeScalarLiteralExpressibleByExtendedGraphemeClusterLiteral 对于仅包含单个字符的字符串文字。每个案例都必须有一个唯一的名称，并被分配一个唯一的原始值。

如果原始值类型被指定为 Int 并且你没有显式地为案例分配值，它们将被隐式分配值 0, 1, 2, 等等。每个未分配的类型案例 Int 都隐式分配了一个原始值，该值从前一个案例的原始值自动递增。

```swift
enum ExampleEnum: Int {
    case a, b, c = 5, d
}
```

在上面的例子中，原始值为 is 和值为 is 。并且因为 的值被显式设置为，所以 的值自动从 递增，因此为。ExampleEnum.a0ExampleEnum.b1ExampleEnum.c5ExampleEnum.d56

如果原始值类型被指定为 String 并且你没有显式地为案例分配值，则每个未分配的案例都被隐式分配一个字符串，其文本与该案例的名称相同。

```swift
enum GamePlayMode: String {
    case cooperative, individual, competitive
}
```

在上面的示例中，原始值为，原始值为，原始值为。GamePlayMode.cooperative"cooperative"GamePlayMode.individual"individual"GamePlayMode.competitive"competitive"

具有原始值类型情况的枚举隐式符合 Swift 标准库中定义的协议。因此，它们有一个属性和一个带有签名的可失败初始化器。你可以使用该属性来访问枚举案例的原始值，如. 你还可以使用原始值来查找相应的情况（如果有），方法是调用枚举的可失败初始化器，如中，它返回一个可选的情况。有关更多信息和查看原始值类型案例的示例，请参阅原始值。RawRepresentablerawValueinit?(rawValue: RawValue)rawValueExampleEnum.b.rawValueExampleEnum(rawValue: 5)

## 访问枚举案例

要引用枚举类型的大小写，请使用点 ( .) 语法，如. 当枚举类型可以从上下文中推断出来时，你可以省略它（点仍然是必需的），如枚举语法和隐式成员表达式中所述。EnumerationType.enumerationCase

要检查枚举案例的值，请使用 switch 语句，如使用 Switch 语句匹配枚举值中所示。枚举类型与语句的 case 块中的枚举 case 模式进行模式匹配 switch，如 Enumeration Case Pattern 中所述。

:::note 枚举声明的语法

```
enum-declaration → attributes? access-level-modifier? union-style-enum

enum-declaration → attributes? access-level-modifier? raw-value-style-enum

union-style-enum → indirect? enum enum-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? { union-style-enum-members? }

union-style-enum-members → union-style-enum-member union-style-enum-members?

union-style-enum-member → declaration | union-style-enum-case-clause | compiler-control-statement

union-style-enum-case-clause → attributes? indirect? case union-style-enum-case-list

union-style-enum-case-list → union-style-enum-case | union-style-enum-case , union-style-enum-case-list

union-style-enum-case → enum-case-name tuple-type?

enum-name → identifier

enum-case-name → identifier

raw-value-style-enum → enum enum-name generic-parameter-clause? type-inheritance-clause generic-where-clause? { raw-value-style-enum-members }

raw-value-style-enum-members → raw-value-style-enum-member raw-value-style-enum-members?

raw-value-style-enum-member → declaration | raw-value-style-enum-case-clause | compiler-control-statement

raw-value-style-enum-case-clause → attributes? case raw-value-style-enum-case-list

raw-value-style-enum-case-list → raw-value-style-enum-case | raw-value-style-enum-case , raw-value-style-enum-case-list

raw-value-style-enum-case → enum-case-name raw-value-assignment?

raw-value-assignment → = raw-value-literal

raw-value-literal → numeric-literal | static-string-literal | boolean-literal
```

:::

## 结构声明

结构声明将命名的结构类型引入到你的程序中。结构声明使用 struct 关键字声明并具有以下形式：

```swift
struct <#structure name#>: <#adopted protocols#> {
   <#declarations#>
}
```

结构体包含零个或多个声明。这些声明可以包括存储属性和计算属性、类型属性、实例方法、类型方法、初始化器、下标、类型别名，甚至其它结构、类、参与者和枚举声明。结构声明不能包含析构器或协议声明。有关包含各种声明的结构的讨论和几个示例，请参阅结构和类。

结构类型可以采用任意数量的协议，但不能从类、枚举或其它结构继承。

可以通过三种方式创建先前声明的结构的实例：

- 调用结构中声明的其中一个初始化器，如初始化器中所述。
- 如果未声明初始化器，请调用结构的成员初始化器，如结构类型的成员初始化器中所述。
- 如果没有声明初始化器，并且结构声明的所有属性都被赋予了初始值，则调用结构的默认初始化器，如默认初始化器中所述。

初始化结构的声明属性的过程在初始化中描述。

可以使用点 ( .) 语法访问结构实例的属性，如访问属性中所述。

结构是值类型；当分配给变量或常量时，或者当作为参数传递给函数调用时，结构的实例被复制。有关值类型的信息，请参阅结构和枚举是值类型。

你可以使用扩展声明来扩展结构类型的行为，如扩展声明中所述。

:::note 结构声明的语法

```
struct-declaration → attributes? access-level-modifier? struct struct-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? struct-body

struct-name → identifier

struct-body → { struct-members? }

struct-members → struct-member struct-members?

struct-member → declaration | compiler-control-statement
```

:::

## 类声明

类声明将命名的类类型引入到你的程序中。类声明使用 class 关键字声明并具有以下形式：

```swift
class <#class name#>: <#superclass#>, <#adopted protocols#> {
   <#declarations#>
}
```

类的主体包含零个或多个声明。这些声明可以包括存储属性和计算属性、实例方法、类型方法、初始化器、单个析构器、下标、类型别名，甚至其它类、结构、参与者和枚举声明。类声明不能包含协议声明。有关包含各种声明的类的讨论和几个示例，请参阅结构和类。

一个类类型只能继承自一个父类，即它的超类，但可以采用任意数量的协议。超类首先出现在类名和冒号之后，然后是任何采用的协议。泛型类可以继承自其它泛型和非泛型类，但非泛型类只能继承自其它非泛型类。当你在冒号后写一个泛型超类的名称时，你必须包括该泛型类的全名，包括它的泛型参数子句。

正如 Initializer Declaration 中所讨论的，类可以有指定的和便利的初始化器。类的指定初始化器必须初始化该类的所有已声明属性，并且必须在调用其超类的任何指定初始化器之前执行此操作。

类可以覆盖其超类的属性、方法、下标和初始化器。重写的属性、方法、下标和指定的初始化器必须用 override 声明修饰器标记。

要要求子类实现超类的初始化器，请使用 required 声明修饰器标记超类的初始化器。该初始化器的子类实现也必须用 required 声明修饰器标记。

虽然在超类中声明的属性和方法被当前类继承，但是在超类中声明的指定初始化器只有在子类满足自动初始化器继承中描述的条件时才会被继承。Swift 类不继承自通用基类。

有两种方法可以创建先前声明的类的实例：

调用类中声明的其中一个初始化器，如初始化器中所述。

如果没有声明初始化器，并且类声明的所有属性都被赋予了初始值，则调用类的默认初始化器，如默认初始化器中所述。

使用点 () 语法访问类实例的属性.，如访问属性中所述。

类是引用类型；当分配给变量或常量，或作为参数传递给函数调用时，类的实例被引用，而不是被复制。有关引用类型的信息，请参阅类是引用类型。

你可以使用扩展声明来扩展类类型的行为，如扩展声明中所述。

:::note 类声明的语法

```
class-declaration → attributes? access-level-modifier? final? class class-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? class-body

class-declaration → attributes? final access-level-modifier? class class-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? class-body

class-name → identifier

class-body → { class-members? }

class-members → class-member class-members?

class-member → declaration | compiler-control-statement
```

:::

## 演员宣言

actor 声明将命名的 actor 类型引入到你的程序中。Actor 声明使用关键字声明 actor，并具有以下形式：

```swift
actor <#actor name#>: <#adopted protocols#> {
    <#declarations#>
}
```

actor 的主体包含零个或多个声明。这些声明可以包括存储属性和计算属性、实例方法、类型方法、初始化器、单个析构器、下标、类型别名，甚至其它类、结构和枚举声明。有关包含各种声明的参与者的讨论和几个示例，请参阅参与者。

参与者类型可以采用任意数量的协议，但不能从类、枚举、结构或其它参与者继承。但是，标有该@objc 属性的 actor 隐式符合协议，并作为 的子类型暴露给 Objective-C 运行时。NSObjectProtocolNSObject

有两种方法可以创建先前声明的 actor 的实例：

- 如 Initializers 中所述，调用在 actor 中声明的其中一个初始化器。
- 如果没有声明初始化器，并且 actor 声明的所有属性都被赋予了初始值，则调用 actor 的默认初始化器，如默认初始化器中所述。

默认情况下，参与者的成员与该参与者隔离。代码，例如方法的主体或属性的 getter，在该参与者上执行。actor 内部的代码可以与它们同步交互，因为该代码已经在同一个 actor 上运行，但 actor 外部的代码必须用 标记它们，以 await 指示该代码正在另一个 actor 上异步运行代码。关键路径不能引用参与者的孤立成员。Actor 隔离的存储属性可以作为输入输出参数传递给同步函数，但不能传递给异步函数。

Actor 也可以有非隔离成员，其声明用 nonisolated 关键字标记。非隔离成员的执行方式类似于 actor 外部的代码：它不能与 actor 的任何隔离状态交互，并且调用者在使用它时不会标记它 await。

参与者的成员@objc 只有在非隔离或异步时才可以用属性标记。

初始化 actor 声明的属性的过程在 Initialization 中描述。

可以使用点 () 语法访问 actor 实例的属性.，如访问属性中所述。

Actor 是引用类型；当分配给变量或常量时，或者当作为参数传递给函数调用时，参与者的实例被引用，而不是被复制。有关引用类型的信息，请参阅类是引用类型。

你可以使用扩展声明来扩展结构类型的行为，如扩展声明中所述。

:::note 演员声明的语法

```
actor-declaration → attributes? access-level-modifier? actor actor-name generic-parameter-clause? type-inheritance-clause? generic-where-clause? actor-body

actor-name → identifier

actor-body → { actor-members? }

actor-members → actor-member actor-members?

actor-member → declaration | compiler-control-statement
```

:::

## 协议声明

协议声明将命名的协议类型引入到你的程序中。协议声明使用 protocol 关键字在全局范围内声明，并具有以下形式：

```swift
protocol <#protocol name#>: <#inherited protocols#> {
   <#protocol member declarations#>
}
```

协议的主体包含零个或多个协议成员声明，​​ 它们描述了采用该协议的任何类型必须满足的一致性要求。特别是，协议可以声明符合类型必须实现某些属性、方法、初始化器和下标。协议还可以声明特殊类型的类型别名，称为关联类型，它可以指定协议的各种声明之间的关系。协议声明不能包含类、结构、枚举或其它协议声明。协议成员声明在下面详细讨论。

协议类型可以继承自任意数量的其它协议。当一种协议类型从其它协议继承时，来自其它协议的要求集合被聚合，并且从当前协议继承的任何类型都必须符合所有这些要求。有关如何使用协议继承的示例，请参阅协议继承。

:::note
你还可以使用协议组合类型聚合多个协议的一致性要求，如协议组合类型和协议组合中所述。
:::

你可以通过在该类型的扩展声明中采用协议来向先前声明的类型添加协议一致性。在扩展中，你必须实现所有采用的协议的要求。如果该类型已经实现了所有要求，你可以将扩展声明的主体留空。

默认情况下，符合协议的类型必须实现协议中声明的所有属性、方法和下标。也就是说，你可以使用声明 optional 修饰器标记这些协议成员声明，​​ 以指定符合类型的实现是可选的。修饰器 optional 只能应用于标有该 objc 属性的成员，并且只能应用于标有该属性的协议成员 objc。因此，只有类类型可以采用并遵守包含可选成员要求的协议。有关如何使用 optional 声明修饰器的更多信息以及有关如何访问可选协议成员的指南——例如，当你不确定是否符合标准的类型实现它们时——请参阅任择议定书要求。

枚举的情况可以满足类型成员的协议要求。具体来说，没有任何关联值的枚举案例满足 type 的 get-only 类型变量的协议要求 Self，而具有关联值的枚举案例满足返回 Self 其参数及其参数标签与案例的关联值匹配的函数的协议要求. 例如：

```swift
protocol SomeProtocol {
    static var someValue: Self { get }
    static func someFunction(x: Int) -> Self
}
enum MyEnum: SomeProtocol {
    case someValue
    case someFunction(x: Int)
}
```

要将协议的采用仅限于类类型，请在冒号后的继承协议列表中包含该协议。例如，以下协议只能由类类型采用：AnyObject

```swift
protocol SomeProtocol: AnyObject {
    /* Protocol members go here */
}
```

任何继承自标有要求的协议的协议同样只能被类类型采用。AnyObject

:::note
如果协议标有属性 objc，则要求隐式应用于该协议；没有必要明确地用要求标记协议。AnyObjectAnyObject
:::

协议是命名类型，因此它们可以出现在代码中与其它命名类型相同的所有位置，如协议作为类型中所讨论的那样。但是，你不能构造协议的实例，因为协议实际上并不提供它们指定的要求的实现。

你可以使用协议来声明类或结构的委托应实现哪些方法，如委托中所述。

:::note 协议声明的语法

```
protocol-declaration → attributes? access-level-modifier? protocol protocol-name type-inheritance-clause? generic-where-clause? protocol-body

protocol-name → identifier

protocol-body → { protocol-members? }

protocol-members → protocol-member protocol-members?

protocol-member → protocol-member-declaration | compiler-control-statement

protocol-member-declaration → protocol-property-declaration

protocol-member-declaration → protocol-method-declaration

protocol-member-declaration → protocol-initializer-declaration

protocol-member-declaration → protocol-subscript-declaration

protocol-member-declaration → protocol-associated-type-declaration

protocol-member-declaration → typealias-declaration
```

:::

## 协议财产声明

协议声明符合类型必须通过在协议声明的主体中包含协议属性声明来实现属性。协议属性声明有一种特殊形式的变量声明：

```swift
var <#property name#>: <#type#> { get set }
```

与其它协议成员声明一样，这些属性声明仅声明符合协议的类型的 getter 和 setter 要求。因此，你不会直接在声明它的协议中实现 getter 或 setter。

符合类型可以通过多种方式满足 getter 和 setter 要求。如果属性声明同时包含 theget 和 set 关键字，则符合类型可以使用可读可写的存储变量属性或计算属性（即同时实现 getter 和 setter 的属性）来实现它。但是，该属性声明不能作为常量属性或只读计算属性来实现。如果属性声明仅包含 get 关键字，则可以将其实现为任何类型的属性。有关实现协议属性要求的符合类型的示例，请参阅属性要求。

要在协议声明中声明类型属性要求，请使用关键字标记属性声明 static。符合协议的结构和枚举使用关键字声明属性 static，符合协议的类使用 static 或 class 关键字声明属性。将协议一致性添加到结构、枚举或类的扩展使用与它们扩展使用的类型相同的关键字。为类型属性要求提供默认实现的扩展使用关键字 static。

另见变量声明。

:::note 协议属性声明的语法

```
protocol-property-declaration → variable-declaration-head variable-name type-annotation getter-setter-keyword-block
```

:::

## 协议方法声明

协议声明符合类型必须通过在协议声明的主体中包含协议方法声明来实现方法。协议方法声明与函数声明具有相同的形式，但有两个例外：它们不包含函数体，并且你不能提供任何默认参数值作为函数声明的一部分。有关实现协议方法要求的符合类型的示例，请参阅方法要求。

要在协议声明中声明类或静态方法要求，请使用声明修饰器标记方法声明 static。符合协议的结构和枚举使用关键字声明方法 static，符合协议的类使用或 static 关键字声明方法 class。将协议一致性添加到结构、枚举或类的扩展使用与它们扩展使用的类型相同的关键字。为类型方法要求提供默认实现的扩展使用 static 关键字。

另请参阅函数声明。

:::note 协议方法声明的语法

```
protocol-method-declaration → function-head function-name generic-parameter-clause? function-signature generic-where-clause?
```

:::

## 协议初始化声明

协议声明符合类型必须通过在协议声明的主体中包含协议初始化器声明来实现初始化器。协议初始化器声明与初始化器声明具有相同的形式，只是它们不包括初始化器的主体。

一致类型可以通过实现非失败初始化器或可 init!失败初始化器来满足非失败协议初始化器要求。符合类型可以通过实现任何类型的初始化器来满足可失败协议初始化器的要求。

required 当一个类实现一个初始化器以满足协议的初始化器要求时，如果该类尚未用声明修饰器标记，则初始化器必须用 final 声明修饰器标记。

另请参阅初始化器声明。

:::note 协议初始化器声明的语法

```
protocol-initializer-declaration → initializer-head generic-parameter-clause? parameter-clause throws? generic-where-clause?

protocol-initializer-declaration → initializer-head generic-parameter-clause? parameter-clause rethrows generic-where-clause?
```

:::

## 协议下标声明

协议声明符合类型必须通过在协议声明的主体中包含协议下标声明来实现下标。协议下标声明有一种特殊形式的下标声明：

```swift
subscript (<#parameters#>) -> <#return type#> { get set }
```

下标声明只声明符合协议的类型的最低 getter 和 setter 实现要求。如果下标声明同时包含 theget 和 set 关键字，则符合类型必须同时实现 getter 和 setter 子句。如果下标声明仅包含 get 关键字，则符合类型必须至少实现一个 getter 子句，并且可以选择实现一个 setter 子句。

要在协议声明中声明静态下标要求，请使用声明 static 修饰器标记下标声明。符合协议的结构和枚举用关键字声明下标 static，符合协议的类用 static 或 class 关键字声明下标。将协议一致性添加到结构、枚举或类的扩展使用与它们扩展使用的类型相同的关键字。为静态下标要求提供默认实现的扩展使用 static 关键字。

另见下标声明。

:::note 协议下标声明的语法

```
protocol-subscript-declaration → subscript-head subscript-result generic-where-clause? getter-setter-keyword-block
```

:::

## 协议关联类型声明

协议使用关键字声明关联类型 associatedtype。关联类型为用作协议声明一部分的类型提供别名。关联类型类似于泛型参数子句中的类型参数，但它们与 Self 声明它们的协议相关联。在该上下文中，Self 指的是符合协议的最终类型。有关更多信息和示例，请参阅关联类型。

where 你在协议声明中使用泛型子句来向从另一个协议继承的关联类型添加约束，而无需重新声明关联类型。例如，下面的声明是等价的：SubProtocol

```swift
protocol SomeProtocol {
    associatedtype SomeType
}

protocol SubProtocolA: SomeProtocol {
    // This syntax produces a warning.
    associatedtype SomeType: Equatable
}

// This syntax is preferred.
protocol SubProtocolB: SomeProtocol where SomeType: Equatable { }
```

另请参阅类型别名声明。

:::note 协议关联类型声明的语法

```
protocol-associated-type-declaration → attributes? access-level-modifier? associatedtype typealias-name type-inheritance-clause? typealias-assignment? generic-where-clause?
```

:::

## 初始化声明

初始化器声明将类、结构或枚举的初始化器引入到你的程序中。初始化器声明是使用 init 关键字声明的，有两种基本形式。

结构、枚举和类类型可以有任意数量的初始化器，但类初始化器的规则和相关行为是不同的。与结构和枚举不同，类有两种初始化器：指定初始化器和便利初始化器，如初始化中所述。

以下形式声明了结构、枚举和类的指定初始化器的初始化器：

```swift
init(<#parameters#>) {
   <#statements#>
}
```

类的指定初始化器直接初始化类的所有属性。它不能调用同一个类的任何其它初始化器，如果该类有超类，它必须调用超类的指定初始化器之一。如果该类从其超类继承了任何属性，则必须先调用超类的指定初始化器之一，然后才能在当前类中设置或修改这些属性中的任何一个。

指定的初始化器只能在类声明的上下文中声明，因此不能使用扩展声明添加到类中。

结构和枚举中的初始化器可以调用其它声明的初始化器来委托部分或全部初始化过程。

要为类声明便利初始化器，请使用声明 convenience 修饰器标记初始化器声明。

```swift
convenience init(<#parameters#>) {
   <#statements#>
}
```

便利初始化器可以将初始化过程委托给另一个便利初始化器或类的指定初始化器之一。也就是说，初始化过程必须以调用最终初始化类属性的指定初始化器结束。便利初始化器不能调用超类的初始化器。

你可以使用声明修饰器标记指定初始化器和便利初始化器 required，以要求每个子类都实现初始化器。子类对该初始化器的实现也必须用 required 声明修饰器标记。

默认情况下，超类中声明的初始化器不会被子类继承。也就是说，如果一个子类使用默认值初始化它所有存储的属性并且没有定义它自己的任何初始化器，它会继承超类的所有初始化器。如果子类重写了超类的所有指定构造器，它就继承了超类的便利构造器。

与方法、属性和下标一样，你需要使用 override 声明修饰器标记被覆盖的指定初始化器。

:::note
如果你用声明修饰器标记一个初始化器，当你在子类中覆盖所需的初始化器时，required 你不会也用修饰器标记初始化器。override
:::

就像函数和方法一样，初始化器可以抛出或重新抛出错误。就像函数和方法一样，你可以在初始化器的参数之后使用 throwsor 关键字来指示适当的行为。rethrows 同样，初始化器可以是异步的，你可以使用 async 关键字来表明这一点。

要查看各种类型声明中的初始化器示例，请参阅 Initialization。

## 失败的初始化器

可失败初始化器是一种初始化器类型，它产生一个可选实例或一个隐式解包的可选实例，该实例是声明初始化器的类型。结果，可失败的初始化器可以返回 nil 以指示初始化失败。

init 要声明生成可选实例的可失败构造器，请在构造器声明 ( ) 中的关键字后附加一个问号 init?。要声明生成隐式展开的可选实例的可失败初始化器，请附加一个感叹号 ( init!)。下面的示例显示了一个 init?可失败的初始化器，它生成一个结构的可选实例。

```swift
struct SomeStruct {
    let property: String
    // produces an optional instance of 'SomeStruct'
    init?(input: String) {
        if input.isEmpty {
            // discard 'self' and return 'nil'
            return nil
        }
        property = input
    }
}
```

调用 init?可失败构造器的方式与调用非可失败构造器的方式相同，只是必须处理结果的可选性。

```swift
if let actualInstance = SomeStruct(input: "Hello") {
    // do something with the instance of 'SomeStruct'
} else {
    // initialization of 'SomeStruct' failed and the initializer returned 'nil'
}
```

可失败构造器可以 nil 在构造器主体实现的任何时候返回。

可失败初始化器可以委托给任何类型的初始化器。一个不可失败的初始化器可以委托给另一个不可失败的初始化器或一个 init!可失败的初始化器。一个不可失败的初始化器可以 init?通过强制展开超类初始化器的结果来委托给一个可失败的初始化器——例如，通过写.super.init()!

初始化失败通过初始化委托传播。具体来说，如果可失败构造器委托给失败并返回的构造器 nil，那么委托的构造器也会失败并隐式返回 nil。如果一个不可失败的初始化器委托给一个 init!失败并返回的可失败初始化器 nil，则会引发运行时错误（就好像你使用!运算符来解包一个有 nil 值的可选）。

可失败的指定构造器可以在子类中被任何类型的指定构造器覆盖。非可失败的指定构造器只能在子类中被非可失败的指定构造器覆盖。

有关更多信息和查看可失败初始化器的示例，请参阅可失败初始化器。

:::note 初始化声明的语法

```
initializer-declaration → initializer-head generic-parameter-clause? parameter-clause async? throws? generic-where-clause? initializer-body

initializer-declaration → initializer-head generic-parameter-clause? parameter-clause async? rethrows generic-where-clause? initializer-body

initializer-head → attributes? declaration-modifiers? init

initializer-head → attributes? declaration-modifiers? init ?

initializer-head → attributes? declaration-modifiers? init !

initializer-body → code-block
```

:::

## 析构器声明

析构器声明为类类型声明一个析构器。Deinitializers 不带参数并且具有以下形式：

```swift
deinit {
   <#statements#>
}
```

当不再有任何对类对象的引用时，就在类对象被释放之前，自动调用析构器。析构器只能在类声明的主体中声明——但不能在类的扩展中——并且每个类最多可以有一个。

子类继承其超类的析构器，它在子类对象被释放之前隐式调用。在其继承链中的所有析构器都完成执行之前，子类对象不会被释放。

不直接调用析构器。

有关如何在类声明中使用反初始化器的示例，请参阅反初始化。

:::note 去初始化器声明的语法

```
deinitializer-declaration → attributes? deinit code-block
```

:::

## 扩展声明

扩展声明允许你扩展现有类型的行为。扩展声明使用关键字声明 extension 并具有以下形式：

```swift
extension <#type name#> where <#requirements#> {
   <#declarations#>
}
```

扩展声明的主体包含零个或多个声明。这些声明可以包括计算属性、计算类型属性、实例方法、类型方法、初始化器、下标声明，甚至类、结构和枚举声明。扩展声明不能包含析构器或协议声明、存储属性、属性观察器或其它扩展声明。协议扩展中的声明不能被标记 final。有关包含各种声明的扩展的讨论和几个示例，请参阅扩展。

如果类型名称是类、结构或枚举类型，则扩展会扩展该类型。如果类型名称是协议类型，则扩展扩展符合该协议的所有类型。

扩展泛型类型或具有关联类型的协议的扩展声明可以包含需求。如果扩展类型或符合扩展协议的类型的实例满足要求，则该实例获得声明中指定的行为。

扩展声明可以包含初始化器声明。也就是说，如果你要扩展的类型是在另一个模块中定义的，则初始化器声明必须委托给已在该模块中定义的初始化器，以确保正确初始化该类型的成员。

现有类型的属性、方法和初始化器不能在该类型的扩展中被覆盖。

扩展声明可以通过指定采用的协议来向现有类、结构或枚举类型添加协议一致性：

```swift
extension <#type name#>: <#adopted protocols#> where <#requirements#> {
   <#declarations#>
}
```

扩展声明不能向现有类添加类继承，因此你只能在类型名称和冒号后指定协议列表。

## 条件一致性

你可以扩展泛型类型以有条件地符合协议，以便该类型的实例仅在满足特定要求时才符合协议。你可以通过在扩展声明中包含要求来为协议添加条件一致性。

在某些通用上下文中不使用覆盖的要求
在某些通用上下文中，从有条件地符合协议而获得行为的类型并不总是使用该协议要求的专门实现。为了说明此行为，以下示例定义了两个协议和一个有条件地符合这两个协议的泛型类型。

```swift
protocol Loggable {
    func log()
}
extension Loggable {
    func log() {
        print(self)
    }
}

protocol TitledLoggable: Loggable {
    static var logTitle: String { get }
}
extension TitledLoggable {
    func log() {
        print("\(Self.logTitle): \(self)")
    }
}

struct Pair<T>: CustomStringConvertible {
    let first: T
    let second: T
    var description: String {
        return "(\(first), \(second))"
    }
}

extension Pair: Loggable where T: Loggable { }
extension Pair: TitledLoggable where T: TitledLoggable {
    static var logTitle: String {
        return "Pair of '\(T.logTitle)'"
    }
}

extension String: TitledLoggable {
    static var logTitle: String {
        return "String"
    }
}
```

只要其泛型类型分别符合 or ，该 Pair 结构就符合 Loggableand 。在下面的示例中，是 的一个实例，它符合因为符合。当直接调用该方法时，将使用包含标题字符串的专用版本。`TitledLoggableLoggableTitledLoggableoneAndTwoPair<String>TitledLoggableStringTitledLoggablelog()oneAndTwo`

```swift
let oneAndTwo = Pair(first: "one", second: "two")
oneAndTwo.log()
// Prints "Pair of 'String': (one, two)"
```

但是，当用于通用上下文或作为协议实例时，不使用专用版本。Swift 通过仅参考需要符合的最低要求来选择要调用的实现。因此，改用协议提供的默认实现。oneAndTwoLoggablelog()PairLoggableLoggable

```swift
func doSomething<T: Loggable>(with x: T) {
    x.log()
}
doSomething(with: oneAndTwo)
// Prints "(one, two)"
```

log()在传递给 的实例上调用时，自定义标题将从记录的字符串中省略。doSomething(\_:)

## 协议一致性不得冗余

具体类型只能符合特定协议一次。Swift 将冗余协议一致性标记为错误。你可能会在两种情况下遇到此类错误。第一种情况是你多次明确遵守同一协议，但要求不同。第二种情况是你多次隐式继承同一个协议。这些情况将在以下各节中讨论。

## 解决显式冗余

具体类型的多个扩展不能添加对同一协议的一致性，即使扩展的要求是相互排斥的。下面的示例演示了此限制。两个扩展声明试图添加对 Serializable 协议的条件一致性，一个用于包含 Int 元素的数组，一个用于包含 String 元素的数组。

```swift
protocol Serializable {
    func serialize() -> Any
}

extension Array: Serializable where Element == Int {
    func serialize() -> Any {
        // implementation
    }
}
extension Array: Serializable where Element == String {
    func serialize() -> Any {
        // implementation
    }
}
// Error: redundant conformance of 'Array<Element>' to protocol 'Serializable'
```

如果你需要添加基于多个具体类型的条件一致性，请创建一个每个类型都可以遵循的新协议，并在声明条件一致性时使用该协议作为要求。

```swift
protocol SerializableInArray { }
extension Int: SerializableInArray { }
extension String: SerializableInArray { }

extension Array: Serializable where Element: SerializableInArray {
    func serialize() -> Any {
        // implementation
    }
}
```

## 解决隐式冗余

当具体类型有条件地符合协议时，该类型隐式符合具有相同要求的任何父协议。

如果你需要一个类型有条件地符合从单个父协议继承的两个协议，请显式声明符合父协议。这避免了两次根据不同的要求隐式地遵守父协议。

以下示例显式声明 Arrayto 的条件一致性，以避免在声明其条件一致性同时符合新协议 Loggable 时发生冲突。TitledLoggableMarkedLoggable

```swift
protocol MarkedLoggable: Loggable {
    func markAndLog()
}

extension MarkedLoggable {
    func markAndLog() {
        print("----------")
        log()
    }
}

extension Array: Loggable where Element: Loggable { }
extension Array: TitledLoggable where Element: TitledLoggable {
    static var logTitle: String {
        return "Array of '\(Element.logTitle)'"
    }
}
extension Array: MarkedLoggable where Element: MarkedLoggable { }
如果没有显式声明符合条件的扩展Loggable，其它Array扩展将隐式创建这些声明，从而导致错误：

extension Array: Loggable where Element: TitledLoggable { }
extension Array: Loggable where Element: MarkedLoggable { }
// Error: redundant conformance of 'Array<Element>' to protocol 'Loggable'
```

:::note 扩展声明的语法

```
extension-declaration → attributes? access-level-modifier? extension type-identifier type-inheritance-clause? generic-where-clause? extension-body

extension-body → { extension-members? }

extension-members → extension-member extension-members?

extension-member → declaration | compiler-control-statement
```

:::

## 下标声明

下标声明允许你为特定类型的对象添加下标支持，通常用于提供方便的语法来访问集合、列表或序列中的元素。下标声明使用关键字声明 subscript 并具有以下形式：

```swift
subscript (<#parameters#>) -> <#return type#> {
   get {
      <#statements#>
   }
   set(<#setter name#>) {
      <#statements#>
   }
}
```

下标声明只能出现在类、结构、枚举、扩展或协议声明的上下文中。

参数指定一个或多个索引，用于访问下标表达式中相应类型的元素（例如，i 表达式中的 the `object[i]`）。尽管用于访问元素的索引可以是任何类型，但每个参数都必须包含一个类型注释来指定每个索引的类型。返回类型指定被访问的元素的类型。

与计算属性一样，下标声明支持读取和写入访问元素的值。getter 用于读取值，setter 用于写入值。setter 子句是可选的，当只需要 getter 时，可以省略这两个子句，直接返回请求的值即可。也就是说，如果你提供 setter 子句，则还必须提供 getter 子句。

setter 名称和括号是可选的。如果你提供设置器名称，它将用作设置器的参数名称。如果你不提供 setter 名称，则 setter 的默认参数名称是 value. setter 的参数类型与返回类型相同。

你可以在声明它的类型中重载下标声明，只要参数或返回类型与你正在重载的类型不同即可。你还可以覆盖从超类继承的下标声明。这样做时，必须用 override 声明修饰器标记被覆盖的下标声明。

下标参数遵循与函数参数相同的规则，但有两个例外。默认情况下，下标中使用的参数没有参数标签，这与函数、方法和初始化器不同。但是，你可以使用与函数、方法和初始化器相同的语法来提供显式参数标签。此外，下标不能有输入输出参数。下标参数可以有一个默认值，使用特殊类型的参数中描述的语法。

你还可以在协议声明的上下文中声明下标，如协议下标声明中所述。

有关下标的更多信息和查看下标声明的示例，请参阅下标。

## 类型下标声明

要声明由类型而不是类型的实例公开的下标，请使用声明修饰器标记下标声明 static。类可以使用声明修饰器标记类型计算属性，class 而不是允许子类覆盖超类的实现。在类声明中，关键字与使用 the 和声明修饰器 static 标记声明具有相同的效果。classfinal

:::note 下标声明的语法

```
subscript-declaration → subscript-head subscript-result generic-where-clause? code-block

subscript-declaration → subscript-head subscript-result generic-where-clause? getter-setter-block

subscript-declaration → subscript-head subscript-result generic-where-clause? getter-setter-keyword-block

subscript-head → attributes? declaration-modifiers? subscript generic-parameter-clause? parameter-clause

subscript-result → -> attributes? type
```

:::

## 经营者声明

运算符声明将新的中缀、前缀或后缀运算符引入到你的程序中，并使用关键字进行声明 operator。

你可以声明三种不同固定性的运算符：中缀、前缀和后缀。运算符的固定性指定了运算符与其操作数的相对位置。

运算符声明有三种基本形式，每种形式对应一种固定性。infix 运算符的固定性通过在关键字前用, prefix, 或 postfix 声明修饰器标记运算符声明来指定 operator。在每种形式中，运算符的名称只能包含 Operators 中定义的运算符字符。

以下形式声明了一个新的中缀运算符：

```swift
infix operator <#operator name#>: <#precedence group#>
```

中缀运算符是写在其两个操作数之间的二元运算符，例如+表达式 中熟悉的加法运算符 ( ) 1 + 2。

中缀运算符可以选择性地指定一个优先级组。如果省略运算符的优先级组，Swift 将使用默认优先级组 ，它指定的优先级仅高于。有关详细信息，请参阅优先组声明。DefaultPrecedenceTernaryPrecedence

以下形式声明了一个新的前缀运算符：

````swift
prefix operator <#operator name#>
```swift

前缀运算符是紧接在其操作数之前的一元运算符，例如!表达式中的前缀逻辑 NOT 运算符 () !a。

前缀运算符声明不指定优先级。前缀运算符是非关联的。

以下形式声明了一个新的后缀运算符：

```swift
postfix operator <#operator name#>
````

后缀运算符是一元运算符，紧跟在其操作数之后，例如!表达式 中的后缀强制展开运算符 ( ) a!。

与前缀运算符一样，后缀运算符声明不指定优先级。后缀运算符是非关联的。

声明一个新的运算符后，你可以通过声明一个与该运算符同名的静态方法来实现它。静态方法是其中一种类型的成员，运算符将其值作为参数——例如，将 a 乘以 an 的运算符 Double 作为 Intor 结构上的静态方法 Double 实现 Int。如果要实现前缀或后缀运算符，则还必须使用相应的 prefixorpostfix 声明修饰器标记该方法声明。要查看如何创建和实施新运算符的示例，请参阅自定义运算符。

:::note 运算符声明的语法

```
operator-declaration → prefix-operator-declaration | postfix-operator-declaration | infix-operator-declaration

prefix-operator-declaration → prefix operator operator

postfix-operator-declaration → postfix operator operator

infix-operator-declaration → infix operator operator infix-operator-group?

infix-operator-group → : precedence-group-name
```

:::

## 优先组声明

优先级组声明为程序中的中缀运算符优先级引入了一个新的分组。在没有分组括号的情况下，运算符的优先级指定运算符与其操作数绑定的紧密程度。

优先组声明具有以下形式：

```swift
precedencegroup <#precedence group name#> {
    higherThan: <#lower group names#>
    lowerThan: <#higher group names#>
    associativity: <#associativity#>
    assignment: <#assignment#>
}
```

较低的组名和较高的组名列表指定新优先组与现有优先组的关系。优先组属性只能用于引用在当前模块外声明的优先组。当两个运算符相互竞争其操作数时，例如在表达式中，具有较高相对优先级的运算符与其操作数绑定得更紧密。lowerThan2 + 3 \* 5

:::note
使用较低组名和较高组名相互关联的优先级组必须适合单个关系层次结构，但它们不必形成线性层次结构。这意味着优先组可能具有未定义的相对优先级。如果没有分组括号，这些优先级组中的运算符不能彼此相邻使用。
:::

Swift 定义了许多优先级组以配合标准库提供的运算符。例如，加法（+）和减法（-）运算符属于该组，乘法（）和除法（）运算符属于该组。有关 Swift 标准库提供的优先级组的完整列表，请参阅运算符声明。AdditionPrecedence\*/MultiplicationPrecedence

运算符的结合性指定在没有分组括号的情况下如何将具有相同优先级的运算符序列组合在一起。你可以通过编写上下文相关的关键字之一来指定运算符的关联性 left, right, or none— 如果你省略关联性，则默认为 none. 左结合运算符从左到右分组。例如，减法运算符 ( -) 是左结合的，因此表达式 4 - 5 - 6 被分组(4 - 5) - 6 并计算为-7。右结合运算符从右到左分组，以及指定结合律为 none 根本不联系。相同优先级的非关联运算符不能彼此相邻出现。例如，<运算符的结合性为 none，这意味着它 1 < 2 < 3 不是有效的表达式。

优先级组的分配指定运算符在包括可选链接的操作中使用时的优先级。当设置为 时 true，相应优先级组中的运算符在可选链接期间使用与标准库中的赋值运算符相同的分组规则。否则，当设置为 false 或省略时，优先级组中的运算符遵循与不执行赋值的运算符相同的可选链接规则。

:::note 优先组声明的语法

```
precedence-group-declaration → precedencegroup precedence-group-name { precedence-group-attributes? }

precedence-group-attributes → precedence-group-attribute precedence-group-attributes?

precedence-group-attribute → precedence-group-relation

precedence-group-attribute → precedence-group-assignment

precedence-group-attribute → precedence-group-associativity

precedence-group-relation → higherThan : precedence-group-names

precedence-group-relation → lowerThan : precedence-group-names

precedence-group-assignment → assignment : boolean-literal

precedence-group-associativity → associativity : left

precedence-group-associativity → associativity : right

precedence-group-associativity → associativity : none

precedence-group-names → precedence-group-name | precedence-group-name , precedence-group-names

precedence-group-name → identifier
```

:::

## 声明修饰器

声明修饰器是修饰声明的行为或含义的关键字或上下文相关的关键字。你可以通过在声明的属性（如果有）和引入声明的关键字之间编写适当的关键字或上下文相关关键字来指定声明修饰器。

**class**

- 将此修饰器应用于类的成员以指示该成员是类本身的成员，而不是类实例的成员。具有此修饰器和不具有该 final 修饰器的超类成员可以被子类覆盖。

**dynamic**

- 将此修饰器应用于可由 Objective-C 表示的类的任何成员。当你使用修饰器标记成员声明时 dynamic，对该成员的访问总是使用 Objective-C 运行时动态调度。对该成员的访问永远不会被编译器内联或去虚拟化。因为用 dynamic 修饰器标记的声明是使用 Objective-C 运行时分派的，所以它们必须用属性标记 objc。

**final**

- 将此修饰器应用于类或类的属性、方法或下标成员。它应用于一个类以指示该类不能被子类化。它应用于类的属性、方法或下标，以指示类成员不能在任何子类中被覆盖。有关如何使用 final 属性的示例，请参阅防止覆盖。

**lazy**

- 将此修饰器应用于类或结构的存储变量属性，以指示属性的初始值在首次访问属性时最多计算和存储一次。有关如何使用修饰器的示例 lazy，请参阅惰性存储属性。

**optional**

- 将此修饰器应用于协议的属性、方法或下标成员，以指示不需要符合类型来实现这些成员。你只能将修饰器应用于标 optional 有该 objc 属性的协议。因此，只有类类型可以采用并遵守包含可选成员要求的协议。有关如何使用修饰器的更多信息 optional 以及有关如何访问可选协议成员的指导（例如，当你不确定是否符合标准的类型实现它们时），请参阅可选协议要求。

**required**

- 将此修饰器应用于类的指定或便利初始化器，以指示每个子类都必须实现该初始化器。该初始化器的子类实现也必须用 required 修饰器标记。

**static**

- 将此修饰器应用于结构、类、枚举或协议的成员，以指示该成员是该类型的成员，而不是该类型实例的成员。在类声明的范围内，在成员声明上写修饰器与在该成员声明上写和修饰器 static 具有相同的效果。但是，类的常量类型属性是一个例外：在那里具有其正常的非类含义，因为你不能在这些声明上编写 or 。classfinalstaticclassfinal

**unowned**

- 将此修饰器应用于存储变量、常量或存储属性，以指示该变量或属性具有对作为其值存储的对象的无主引用。如果你尝试在对象被释放后访问变量或属性，则会引发运行时错误。和弱引用一样，属性或值的类型必须是类类型；与弱引用不同，该类型是非可选的。有关修饰器的示例和更多信息 unowned，请参阅无主引用。

**unowned(safe)**

- 的明确拼写 unowned。

**unowned(unsafe)**

- 将此修饰器应用于存储变量、常量或存储属性，以指示该变量或属性具有对作为其值存储的对象的无主引用。如果你试图在对象被释放后访问变量或属性，你将访问对象原来所在位置的内存，这是内存不安全的操作。和弱引用一样，属性或值的类型必须是类类型；与弱引用不同，该类型是非可选的。有关修饰器的示例和更多信息 unowned，请参阅无主引用。

**weak**

- 将此修饰器应用于存储变量或存储变量属性，以指示该变量或属性对作为其值存储的对象具有弱引用。变量或属性的类型必须是可选的类类型。如果在对象被释放后访问变量或属性，它的值为 nil。有关修饰器的示例和更多信息 weak，请参阅弱引用。

## 访问控制级别

Swift 提供了五个级别的访问控制：开放、公共、内部、文件私有和私有。你可以使用以下访问级别修饰器之一标记声明，以指定声明的访问级别。访问控制在访问控制中有详细讨论。

**open**

- 将此修饰器应用于声明以指示声明可以由与声明相同的模块中的代码访问和子类化。标有 open 访问级别修饰器的声明也可以由导入包含该声明的模块的模块中的代码访问和子类化。

**public**

- 将此修饰器应用于声明以指示声明可以由与声明相同的模块中的代码访问和子类化。标有 public 访问级别修饰器的声明也可以由导入包含该声明的模块的模块中的代码访问（但不能子类化）。

**internal**

- 将此修饰器应用于声明以指示声明只能由与声明相同的模块中的代码访问。默认情况下，大多数声明都隐式标记了 internal 访问级别修饰器。

**fileprivate**

- 将此修饰器应用于声明以指示声明只能由与声明相同的源文件中的代码访问。

**private**

- 将此修饰器应用于声明以指示声明只能由声明的直接封闭范围内的代码访问。

出于访问控制的目的，同一文件中相同类型的扩展共享一个访问控制范围。如果它们扩展的类型也在同一文件中，则它们共享该类型的访问控制范围。可以从扩展访问类型声明中声明的私有成员，并且可以从其它扩展和类型声明访问在一个扩展中声明的私有成员。

上面的每个访问级别修饰器可选地接受一个参数，该参数由 set 括在括号中的关键字组成（例如，private(set)）。当你想要为变量或下标的 setter 指定访问级别小于或等于变量或下标本身的访问级别时，请使用这种形式的访问级别修饰器，如 Getters 和 Setters 中所述。

:::note 声明修饰器的语法

```
declaration-modifier → class | convenience | dynamic | final | infix | lazy | optional | override | postfix | prefix | required | static | unowned | unowned ( safe ) | unowned ( unsafe ) | weak

declaration-modifier → access-level-modifier

declaration-modifier → mutation-modifier

declaration-modifier → actor-isolation-modifier

declaration-modifiers → declaration-modifier declaration-modifiers?

access-level-modifier → private | private ( set )

access-level-modifier → fileprivate | fileprivate ( set )

access-level-modifier → internal | internal ( set )

access-level-modifier → public | public ( set )

access-level-modifier → open | open ( set )

mutation-modifier → mutating | nonmutating

actor-isolation-modifier → nonisolated
```

:::
