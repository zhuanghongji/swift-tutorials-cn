# 快速浏览 Swift

<DocCaution />

<OriginalLink
  title="探索 Swift 的特性和语法"
  value="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/guidedtour"
/>

传统建议新语言的第一个程序应该打印“Hello, world!” 屏幕上。在 Swift 中，这可以在一行中完成：

```swift
print("Hello, world!")

// tip-next-line
// Prints "Hello, world!"
```

如果您用 C 或 Objective-C 编写过代码，您会觉得这种语法很熟悉——在 Swift 中，这行代码就是一个完整的程序。您不需要为输入/输出或字符串处理等功能导入单独的库。在全局范围内编写的代码用作程序的入口点，因此您不需要函数 main()。您也不需要在每条语句的末尾都写分号。

本导览向您展示如何完成各种编程任务，为您提供足够的信息以开始使用 Swift 编写代码。如果您不理解某些内容，请不要担心——本导览中介绍的所有内容都将在本书的其余部分进行详细解释。

## 简单值

用来 let 做常量和 var 做变量。常量的值不需要在编译时就知道，但你必须恰好为它赋值一次。这意味着您可以使用常量来命名您一次确定但在许多地方使用的值。

```swift
var myVariable = 42
myVariable = 50
let myConstant = 42
```

常量或变量必须与要分配给它的值具有相同的类型。但是，您不必总是明确地写出类型。在创建常量或变量时提供值可让编译器推断其类型。在上面的示例中，编译器推断它是一个整数，因为它的初始值是一个整数。myVariable

如果初始值没有提供足够的信息（或者如果没有初始值），通过在变量后面写它来指定类型，用冒号分隔。

```swift
let implicitInteger = 70
let implicitDouble = 70.0
let explicitDouble: Double = 70
```

:::note 实验
创建一个显式类型为 `Float` 且值为常量 `4` 。
:::

值永远不会隐式转换为另一种类型。如果您需要将值转换为不同的类型，请显式创建所需类型的实例。

```swift
let label = "The width is "
let width = 94
let widthLabel = label + String(width)
```

:::note 实验
用于 `\()` 在字符串中包含浮点计算以及在问候语中包含某人的姓名。
:::

`"""` 对于占用多行的字符串，使用三个双引号 ( )。删除每个引用行开头的缩进，只要它与右引号的缩进相匹配。例如：

```swift
let quotation = """
I said "I have \(apples) apples."
And then I said "I have \(apples + oranges) pieces of fruit."
"""
```

使用方括号 ( ) 创建数组和字典[]，并通过在方括号中写入索引或键来访问它们的元素。最后一个元素后允许有逗号。

```swift
var fruits = ["strawberries", "limes", "tangerines"]
fruits[1] = "grapes"

var occupations = [
    "Malcolm": "Captain",
    "Kaylee": "Mechanic",
 ]
occupations["Jayne"] = "Public Relations"
```

当您添加元素时，数组会自动增长。

```swift
fruits.append("blueberries")
print(fruits)
// Prints "["strawberries", "grapes", "tangerines", "blueberries"]"
```

您还可以使用括号来编写空数组或字典。对于数组，写[]，对于字典，写[:]。

```swift
fruits = []
occupations = [:]
```

如果您将一个空数组或字典分配给一个新变量，或者另一个没有任何类型信息的地方，您需要指定类型。

```swift
let emptyArray: [String] = []
let emptyDictionary: [String: Float] = [:]
```

## 控制流

使用 ifandswitch 进行条件判断，使用 for- in、while 和 repeat-while 进行循环。条件或循环变量周围的括号是可选的。身体周围的支架是必需的。

````swift
let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {
    if score > 50 {
        teamScore += 3
    } else {
        teamScore += 1
    }
}
print(teamScore)
// Prints "11"
```swift

在if语句中，条件必须是一个布尔表达式——这意味着代码如 是if score { ... }一个错误，而不是与零的隐式比较。

您可以将if和let一起使用以处理可能缺失的值。这些值表示为可选值。可选值要么包含一个值，要么包含nil以指示缺少一个值。?在值的类型后面写一个问号 ( ) 以将值标记为可选。

```swift
var optionalString: String? = "Hello"
print(optionalString == nil)
// Prints "false"

var optionalName: String? = "John Appleseed"
var greeting = "Hello!"
if let name = optionalName {
    greeting = "Hello, \(name)"
}
````

:::note 实验
改为。\_ 你得到什么问候？添加一个设置不同问候语的子句 if is 。optionalNamenilelseoptionalNamenil
:::

如果可选值为 nil，则条件为 false 并且跳过大括号中的代码。否则，可选值将被展开并分配给常量 after let，这使得展开后的值在代码块内可用。

处理可选值的另一种方法是使用??运算符提供默认值。如果缺少可选值，则使用默认值。

```swift
let nickname: String? = nil
let fullName: String = "John Appleseed"
let informalGreeting = "Hi \(nickname ?? fullName)"
```

您可以使用更短的拼写来解包一个值，为该解包的值使用相同的名称。

```swift
if let nickname {
    print("Hey, \(nickname)")
}
// Doesn't print anything, because nickname is nil.
```

开关支持任何类型的数据和各种比较操作——它们不限于整数和相等性测试。

```swift
let vegetable = "red pepper"
switch vegetable {
case "celery":
    print("Add some raisins and make ants on a log.")
case "cucumber", "watercress":
    print("That would make a good tea sandwich.")
case let x where x.hasSuffix("pepper"):
    print("Is it a spicy \(x)?")
default:
    print("Everything tastes good in soup.")
}
// Prints "Is it a spicy red pepper?"
```

:::note 实验
尝试删除默认大小写。你得到什么错误？
:::

请注意如何 let 在模式中使用 将与模式匹配的值分配给常量。

执行完匹配的 switch case 内的代码后，程序从 switch 语句中退出。执行不会继续到下一个案例，因此您不需要在每个案例代码的末尾显式地中断开关。

您可以使用 for-in 通过为每个键值对提供一对名称来迭代字典中的项目。字典是无序集合，因此它们的键和值以任意顺序迭代。

```swift
let interestingNumbers = [
    "Prime": [2, 3, 5, 7, 11, 13],
    "Fibonacci": [1, 1, 2, 3, 5, 8],
    "Square": [1, 4, 9, 16, 25],
]
var largest = 0
for (_, numbers) in interestingNumbers {
    for number in numbers {
        if number > largest {
            largest = number
        }
    }
}
print(largest)
// Prints "25"
```

:::note 实验
将 替换\_为变量名，并跟踪哪种数字最大。
:::

用于 while 重复代码块，直到条件发生变化。循环的条件可以放在末尾，以确保循环至少运行一次。

```swift
var n = 2
while n < 100 {
    n *= 2
}
print(n)
// Prints "128"

var m = 2
repeat {
    m *= 2
} while m < 100
print(m)
// Prints "128"
..<您可以通过使用to 创建一系列索引来将索引保持在循环中。

var total = 0
for i in 0..<4 {
    total += i
}
print(total)
// Prints "6"
```

用于..<创建一个忽略其上限值的范围，并用于...创建一个包含两个值的范围。

## 函数和闭包

用于 `func` 声明一个函数。通过在函数名称后加上括号中的参数列表来调用函数。用于->将参数名称和类型与函数的返回类型分开。

```swift
func greet(person: String, day: String) -> String {
    return "Hello \(person), today is \(day)."
}
greet(person: "Bob", day: "Tuesday")
```

:::note 实验
删除 day 参数。添加一个参数以在问候语中包含今天的特色午餐。
:::

默认情况下，函数使用其参数名称作为其参数的标签。在参数名称之前写一个自定义参数标签，或者\_不使用参数标签。

```swift
func greet(_ person: String, on day: String) -> String {
    return "Hello \(person), today is \(day)."
}
greet("John", on: "Wednesday")
```

使用元组生成复合值——例如，从函数返回多个值。元组的元素可以通过名称或编号来引用。

```swift
func calculateStatistics(scores: [Int]) -> (min: Int, max: Int, sum: Int) {
    var min = scores[0]
    var max = scores[0]
    var sum = 0

    for score in scores {
        if score > max {
            max = score
        } else if score < min {
            min = score
        }
        sum += score
    }

    return (min, max, sum)
}
let statistics = calculateStatistics(scores: [5, 3, 100, 3, 9])
print(statistics.sum)
// Prints "120"
print(statistics.2)
// Prints "120"
```

函数可以嵌套。嵌套函数可以访问在外部函数中声明的变量。您可以使用嵌套函数来组织较长或复杂的函数中的代码。

```swift
func returnFifteen() -> Int {
    var y = 10
    func add() {
        y += 5
    }
    add()
    return y
}
returnFifteen()
```

函数是一流的类型。这意味着一个函数可以返回另一个函数作为它的值。

```swift
func makeIncrementer() -> ((Int) -> Int) {
    func addOne(number: Int) -> Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)
```

一个函数可以将另一个函数作为它的参数之一。

```swift
func hasAnyMatches(list: [Int], condition: (Int) -> Bool) -> Bool {
    for item in list {
        if condition(item) {
            return true
        }
    }
    return false
}
func lessThanTen(number: Int) -> Bool {
    return number < 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(list: numbers, condition: lessThanTen)
```

函数实际上是闭包的一种特例：稍后可以调用的代码块。闭包中的代码可以访问在创建闭包的范围内可用的变量和函数之类的东西，即使闭包在执行时处于不同的范围内——你已经看到了一个嵌套函数的例子。您可以通过用大括号 ( ) 包围代码来编写没有名称的闭包{}。用于 in 将参数和返回类型与正文分开。

```swift
numbers.map({ (number: Int) -> Int in
    let result = 3 * number
    return result
})
```

:::note 实验
重写闭包以对所有奇数返回零。
:::

您有多种选择可以更简洁地编写闭包。当闭包的类型已知时，例如委托的回调，您可以省略其参数类型和/或返回类型。单语句闭包隐式返回它们唯一语句的值。

```swift
let mappedNumbers = numbers.map({ number in 3 * number })
print(mappedNumbers)
// Prints "[60, 57, 21, 36]"
```

您可以通过编号而不是名称来引用参数——这种方法在非常短的闭包中特别有用。作为函数的最后一个参数传递的闭包可以紧跟在括号之后。当闭包是函数的唯一参数时，您可以完全省略括号。

```swift
let sortedNumbers = numbers.sorted { $0 > $1 }
print(sortedNumbers)
// Prints "[20, 19, 12, 7]"
```

## 对象和类

使用 class 后跟类名来创建类。类中的属性声明与常量或变量声明的编写方式相同，只是它位于类的上下文中。同样，方法和函数声明的编写方式相同。

```swift
class Shape {
    var numberOfSides = 0
    func simpleDescription() -> String {
        return "A shape with \(numberOfSides) sides."
    }
}
```

:::note 实验
添加一个带有 的常量属性 let，并添加另一个接受参数的方法。
:::

通过在类名后加上括号来创建类的实例。使用点语法访问实例的属性和方法。

```swift
var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
```

这个版本的 Shape 类缺少一些重要的东西：在创建实例时设置类的初始化程序。用于 init 创建一个。

```swift
class NamedShape {
    var numberOfSides: Int = 0
    var name: String

    init(name: String) {
       self.name = name
    }

    func simpleDescription() -> String {
       return "A shape with \(numberOfSides) sides."
    }
}
```

请注意如何 self 将 name 属性与 name 初始化程序的参数区分开来。当您创建类的实例时，初始化器的参数就像函数调用一样被传递。每个属性都需要赋值——在其声明中（如）或在初始化程序中（如）。numberOfSidesname

deinit 如果您需要在释放对象之前执行一些清理，请使用它来创建析构器。

子类在它们的类名之后包括它们的超类名，用冒号分隔。不需要类继承任何标准根类，因此您可以根据需要包含或省略超类。

子类上覆盖超类实现的方法被标记为 override— 意外覆盖方法，没有 override，编译器检测为错误。编译器还会检测 override 实际上并未覆盖超类中任何方法的方法。

```swift
class Square: NamedShape {
    var sideLength: Double

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 4
    }

    func area() -> Double {
        return sideLength * sideLength
    }

    override func simpleDescription() -> String {
        return "A square with sides of length \(sideLength)."
    }
}
let test = Square(sideLength: 5.2, name: "my test square")
test.area()
test.simpleDescription()
```

:::note 实验
创建 called 的另一个子类，将半径和名称作为其初始值设定项的参数。在类上实现一个和一个方法。NamedShapeCirclearea()simpleDescription()Circle
:::

除了存储的简单属性外，属性还可以有 getter 和 setter。

```swift
class EquilateralTriangle: NamedShape {
    var sideLength: Double = 0.0

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 3
    }

    var perimeter: Double {
        get {
             return 3.0 * sideLength
        }
        set {
            sideLength = newValue / 3.0
        }
    }

    override func simpleDescription() -> String {
        return "An equilateral triangle with sides of length \(sideLength)."
    }
}
var triangle = EquilateralTriangle(sideLength: 3.1, name: "a triangle")
print(triangle.perimeter)
// Prints "9.3"
triangle.perimeter = 9.9
print(triangle.sideLength)
// Prints "3.3000000000000003"
```

在 的 setter 中 perimeter，新值具有隐式名称。您可以在 之后的括号中提供明确的名称。newValueset

请注意，该类的初始化程序具有三个不同的步骤：EquilateralTriangle

设置子类声明的属性值。

调用超类的初始化器。

更改超类定义的属性值。任何使用方法、getter 或 setter 的额外设置工作也可以在此时完成。

如果您不需要计算属性但仍需要提供在设置新值之前和之后运行的代码，请使用 and 。只要值在初始值设定项之外发生变化，您提供的代码就会运行。例如，下面的类确保其三角形的边长始终与其正方形的边长相同。willSetdidSet

```swift
class TriangleAndSquare {
    var triangle: EquilateralTriangle {
        willSet {
            square.sideLength = newValue.sideLength
        }
    }
    var square: Square {
        willSet {
            triangle.sideLength = newValue.sideLength
        }
    }
    init(size: Double, name: String) {
        square = Square(sideLength: size, name: name)
        triangle = EquilateralTriangle(sideLength: size, name: name)
    }
}
var triangleAndSquare = TriangleAndSquare(size: 10, name: "another test shape")
print(triangleAndSquare.square.sideLength)
// Prints "10.0"
print(triangleAndSquare.triangle.sideLength)
// Prints "10.0"
triangleAndSquare.square = Square(sideLength: 50, name: "larger square")
print(triangleAndSquare.triangle.sideLength)
// Prints "50.0"
```

使用可选值时，您可以?在方法、属性和下标等操作之前编写。?如果之前的值为 nil，则?忽略之后的所有内容，整个表达式的值为 nil。否则，可选值被展开，并且之后的所有内容都?作用于展开的值。在这两种情况下，整个表达式的值都是可选值。

```swift
let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square")
let sideLength = optionalSquare?.sideLength
```

## 枚举和结构

用于 enum 创建枚举。与类和所有其他命名类型一样，枚举可以具有与之关联的方法。

```swift
enum Rank: Int {
    case ace = 1
    case two, three, four, five, six, seven, eight, nine, ten
    case jack, queen, king

    func simpleDescription() -> String {
        switch self {
        case .ace:
            return "ace"
        case .jack:
            return "jack"
        case .queen:
            return "queen"
        case .king:
            return "king"
        default:
            return String(self.rawValue)
        }
    }
}
let ace = Rank.ace
let aceRawValue = ace.rawValue
```

:::note 实验
Rank 编写一个函数，通过比较原始值来比较两个值。
:::

默认情况下，Swift 分配原始值从零开始，每次递增 1，但您可以通过显式指定值来更改此行为。在上面的例子中，Ace 被明确地赋予了原始值 1，其余的原始值按顺序分配。您还可以使用字符串或浮点数作为枚举的原始类型。使用该属性访问枚举案例的原始值。rawValue

使用初始化程序从原始值创建枚举实例。它返回与原始值匹配的枚举案例，或者如果没有匹配。init?(rawValue:)nilRank

```swift
if let convertedRank = Rank(rawValue: 3) {
    let threeDescription = convertedRank.simpleDescription()
}
```

枚举的 case 值是实际值，而不仅仅是另一种编写原始值的方式。事实上，在没有有意义的原始值的情况下，您不必提供原始值。

```swift
enum Suit {
    case spades, hearts, diamonds, clubs

    func simpleDescription() -> String {
        switch self {
        case .spades:
            return "spades"
        case .hearts:
            return "hearts"
        case .diamonds:
            return "diamonds"
        case .clubs:
            return "clubs"
        }
    }
}
let hearts = Suit.hearts
let heartsDescription = hearts.simpleDescription()
```

:::note 实验
添加一个 color()方法，Suit 为黑桃和梅花返回“黑色”，为红心和方块返回“红色”。
:::

注意上面引用枚举大小写的两种方式 hearts： 当给常量赋值时 hearts，枚举大小写是用它的全名来引用的，因为常量没有明确指定类型。在 switch 内部，枚举 case 由缩写形式引用，因为已知 的值是花色。只要值的类型已知，您就可以使用缩写形式。Suit.hearts.heartsself

如果枚举具有原始值，则这些值作为声明的一部分确定，这意味着特定枚举案例的每个实例始终具有相同的原始值。枚举案例的另一种选择是让值与案例相关联——这些值是在创建实例时确定的，并且它们对于枚举案例的每个实例都可以不同。您可以认为关联值的行为类似于枚举案例实例的存储属性。例如，考虑从服务器请求日出和日落时间的情况。服务器要么以请求的信息作为响应，要么以出错的描述作为响应。

```swift
enum ServerResponse {
    case result(String, String)
    case failure(String)
}

let success = ServerResponse.result("6:00 am", "8:09 pm")
let failure = ServerResponse.failure("Out of cheese.")

switch success {
case let .result(sunrise, sunset):
    print("Sunrise is at \(sunrise) and sunset is at \(sunset).")
case let .failure(message):
    print("Failure...  \(message)")
}
// Prints "Sunrise is at 6:00 am and sunset is at 8:09 pm."
```

:::note 实验
将第三种情况添加到 switch 和 switch 中。ServerResponse
:::

请注意如何从值中提取日出和日落时间，作为将值与 switch case 匹配的一部分。ServerResponse

用于 struct 创建结构。结构支持许多与类相同的行为，包括方法和初始化器。结构和类之间最重要的区别之一是结构在代码中传递时总是被复制，而类是通过引用传递的。

```swift
struct Card {
    var rank: Rank
    var suit: Suit
    func simpleDescription() -> String {
        return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
    }
}
let threeOfSpades = Card(rank: .three, suit: .spades)
let threeOfSpadesDescription = threeOfSpades.simpleDescription()
```

:::note 实验
编写一个函数，该函数返回一个包含一副完整纸牌的数组，其中一张牌由等级和花色的每种组合组成。
:::

## 并发

用于 async 标记异步运行的函数。

```swift
func fetchUserID(from server: String) async -> Int {
    if server == "primary" {
        return 97
    }
    return 501
}
```

await 您通过在异步函数前面写入来标记对异步函数的调用。

```swift
func fetchUsername(from server: String) async -> String {
    let userID = await fetchUserID(from: server)
    if userID == 501 {
        return "John Appleseed"
    }
    return "Guest"
}
```

用于 async let 调用异步函数，让它与其他异步代码并行运行。当您使用它返回的值时，写 await.

```swift
func connectUser(to server: String) async {
    async let userID = fetchUserID(from: server)
    async let username = fetchUsername(from: server)
    let greeting = await "Hello \(username), user ID \(userID)"
    print(greeting)
}
```

用于 Task 从同步代码调用异步函数，而无需等待它们返回。

```swift
Task {
    await connectUser(to: "primary")
}
// Prints "Hello Guest, user ID 97"
```

## 协议和扩展

用于 `protocol` 声明协议。

```swift
protocol ExampleProtocol {
     var simpleDescription: String { get }
     mutating func adjust()
}
```

类、枚举和结构都可以采用协议。

```swift
class SimpleClass: ExampleProtocol {
     var simpleDescription: String = "A very simple class."
     var anotherProperty: Int = 69105
     func adjust() {
          simpleDescription += "  Now 100% adjusted."
     }
}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription

struct SimpleStructure: ExampleProtocol {
     var simpleDescription: String = "A simple structure"
     mutating func adjust() {
          simpleDescription += " (adjusted)"
     }
}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
```

:::note 实验
向 . 添加另一个要求。您需要进行哪些更改才能使它们仍然符合协议？ExampleProtocolSimpleClassSimpleStructure
:::

mutating 请注意在声明中使用关键字来标记修改结构的方法。的声明不需要将它的任何方法标记为变异，因为类上的方法总是可以修改类。SimpleStructureSimpleClass

用于 extension 向现有类型添加功能，例如新方法和计算属性。您可以使用扩展将协议一致性添加到在别处声明的类型，甚至添加到您从库或框架导入的类型。

```swift
extension Int: ExampleProtocol {
    var simpleDescription: String {
        return "The number \(self)"
    }
    mutating func adjust() {
        self += 42
    }
 }
print(7.simpleDescription)
// Prints "The number 7"
```

:::note 实验
Double 为添加属性的类型编写扩展。absoluteValue
:::

您可以像使用任何其他命名类型一样使用协议名称 - 例如，创建具有不同类型但都符合单一协议的对象集合。当您使用类型为协议类型的值时，协议定义之外的方法不可用。

```swift
let protocolValue: ExampleProtocol = a
print(protocolValue.simpleDescription)
// Prints "A very simple class.  Now 100% adjusted."
// print(protocolValue.anotherProperty)  // Uncomment to see the error
```

即使该变量的运行时类型为，编译器也会将其视为给定类型。这意味着您不能意外访问该类除了其协议一致性之外还实现的方法或属性。protocolValueSimpleClassExampleProtocol

## 错误处理

您可以使用采用该 Error 协议的任何类型来表示错误。

```swift
enum PrinterError: Error {
    case outOfPaper
    case noToner
    case onFire
}
```

用于 throw 抛出错误并 throws 标记可以抛出错误的函数。如果您在函数中抛出错误，该函数会立即返回并且调用该函数的代码会处理该错误。

```swift
func send(job: Int, toPrinter printerName: String) throws -> String {
    if printerName == "Never Has Toner" {
        throw PrinterError.noToner
    }
    return "Job sent"
}
```

有几种方法可以处理错误。一种方法是使用 do- catch。在块内，您可以通过在代码前面 do 书写来标记可能引发错误的代码。try 在 catch 块内，除非您给它一个不同的名称，否则会自动为错误指定名称 error。

```swift
do {
    let printerResponse = try send(job: 1040, toPrinter: "Bi Sheng")
    print(printerResponse)
} catch {
    print(error)
}
// Prints "Job sent"
```

## 实验

将打印机名称更改为"Never Has Toner"，以便函数抛出错误。send(job:toPrinter:)

您可以提供多个 catch 块来处理特定错误。你在后面写一个模式 catch 就像你 case 在开关后面做的一样。

```swift
do {
    let printerResponse = try send(job: 1440, toPrinter: "Gutenberg")
    print(printerResponse)
} catch PrinterError.onFire {
    print("I'll just put this over here, with the rest of the fire.")
} catch let printerError as PrinterError {
    print("Printer error: \(printerError).")
} catch {
    print(error)
}
// Prints "Job sent"
```

## 实验

添加代码以在块内引发错误 do。你需要抛出什么样的错误才能让第一个块处理错误 catch？第二块和第三块呢？

处理错误的另一种方法是使用 try?将结果转换为可选。如果函数抛出错误，则丢弃特定错误并且结果为 nil。否则，结果是一个包含函数返回值的可选值。

```swift
let printerSuccess = try? send(job: 1884, toPrinter: "Mergenthaler")
let printerFailure = try? send(job: 1885, toPrinter: "Never Has Toner")
```

用于 defer 编写在函数中所有其他代码之后执行的代码块，就在函数返回之前。无论函数是否抛出错误，代码都会执行。您可以将 defer 设置和清理代码并排编写，即使它们需要在不同时间执行。

```swift
var fridgeIsOpen = false
let fridgeContent = ["milk", "eggs", "leftovers"]

func fridgeContains(_ food: String) -> Bool {
    fridgeIsOpen = true
    defer {
        fridgeIsOpen = false
    }

    let result = fridgeContent.contains(food)
    return result
}
fridgeContains("banana")
print(fridgeIsOpen)
// Prints "false"
```

## 泛型

在尖括号内写一个名称来创建通用函数或类型。

```swift
func makeArray<Item>(repeating item: Item, numberOfTimes: Int) -> [Item] {
    var result: [Item] = []
    for _ in 0..<numberOfTimes {
         result.append(item)
    }
    return result
}
makeArray(repeating: "knock", numberOfTimes: 4)
```

您可以创建函数和方法的通用形式，以及类、枚举和结构。

```swift
// Reimplement the Swift standard library's optional type
enum OptionalValue<Wrapped> {
    case none
    case some(Wrapped)
}
var possibleInteger: OptionalValue<Int> = .none
possibleInteger = .some(100)
```

在主体之前使用 where 来指定需求列表——例如，要求类型实现协议，要求两种类型相同，或者要求类具有特定的超类。

```swift
func anyCommonElements<T: Sequence, U: Sequence>(_ lhs: T, _ rhs: U) -> Bool
    where T.Element: Equatable, T.Element == U.Element
{
    for lhsItem in lhs {
        for rhsItem in rhs {
            if lhsItem == rhsItem {
                return true
            }
        }
    }
   return false
}
anyCommonElements([1, 2, 3], [3])
```

:::note 实验
修改该函数以创建一个返回任意两个序列共有元素的数组的函数。anyCommonElements(_:_:)
:::

写作 `<T: Equatable>` 与写作相同 `<T> ... where T: Equatable` 。
