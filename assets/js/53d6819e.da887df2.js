"use strict";(self.webpackChunkswift_tutorials_cn=self.webpackChunkswift_tutorials_cn||[]).push([[6418],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),g=i,m=d["".concat(s,".").concat(g)]||d[g]||u[g]||r;return n?a.createElement(m,o(o({ref:t},c),{},{components:n})):a.createElement(m,o({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=g;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},3050:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={},o="\u6807\u91cf\u6570\u636e\u7c7b\u578b",l={unversionedId:"metal-shading-language-specification/scalar-data-types/index",id:"metal-shading-language-specification/scalar-data-types/index",title:"\u6807\u91cf\u6570\u636e\u7c7b\u578b",description:"Metal \u652f\u6301\u8868 2.1 \u4e2d\u5217\u51fa\u7684\u6807\u91cf\u7c7b\u578b\u3002Metal \u4e0d \u652f\u6301 double\u3001long long\u3001unsigned long long \u548c long double \u6570\u636e\u7c7b\u578b\u3002",source:"@site/docs/metal-shading-language-specification/scalar-data-types/index.mdx",sourceDirName:"metal-shading-language-specification/scalar-data-types",slug:"/metal-shading-language-specification/scalar-data-types/",permalink:"/swift-tutorials-cn/docs/metal-shading-language-specification/scalar-data-types/",draft:!1,editUrl:"https://github.com/zhuanghongji/swift-tutorials-cn/docs/metal-shading-language-specification/scalar-data-types/index.mdx",tags:[],version:"current",lastUpdatedAt:1695274250,formattedLastUpdatedAt:"2023\u5e749\u670821\u65e5",frontMatter:{},sidebar:"metalshadinglanguagespecificationSidebar",previous:{title:"Metal \u5750\u6807\u7cfb",permalink:"/swift-tutorials-cn/docs/metal-shading-language-specification/metal-coordinate-systems/"},next:{title:"\u5411\u91cf\u6570\u636e\u7c7b\u578b",permalink:"/swift-tutorials-cn/docs/metal-shading-language-specification/vector-data-types/"}},s={},p=[],c=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},d=c("ToBePolishedAfterTranslation"),u=c("OriginalPDF"),g=c("TableView"),m={toc:p},f="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(f,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"\u6807\u91cf\u6570\u636e\u7c7b\u578b"},"\u6807\u91cf\u6570\u636e\u7c7b\u578b"),(0,i.kt)(d,{mdxType:"ToBePolishedAfterTranslation"}),(0,i.kt)(u,{title:"2.1 Scalar Data Types",mdxType:"OriginalPDF"}),(0,i.kt)("p",null,"Metal \u652f\u6301\u8868 2.1 \u4e2d\u5217\u51fa\u7684\u6807\u91cf\u7c7b\u578b\u3002Metal ",(0,i.kt)("strong",{parentName:"p"},"\u4e0d")," \u652f\u6301 ",(0,i.kt)("inlineCode",{parentName:"p"},"double"),"\u3001",(0,i.kt)("inlineCode",{parentName:"p"},"long long"),"\u3001",(0,i.kt)("inlineCode",{parentName:"p"},"unsigned long long")," \u548c ",(0,i.kt)("inlineCode",{parentName:"p"},"long double")," \u6570\u636e\u7c7b\u578b\u3002"),(0,i.kt)(g,{num:"2.1",title:"Metal scalar data types",headers:["Type","Description"],datasList:[["bool","A conditional data type that has the value of either true or false. \nThe value true expands to the integer constant 1, and the value false expands to the integer constant 0. "],["char\nint8_t","A signed two\u2019s complement 8-bit integer. "],["unsigned char\nuchar\nuint8_t","An unsigned 8-bit integer."],["short\nint16_t","A signed two\u2019s complement 16-bit integer."],["unsigned short\nushort\nuint16_t","An unsigned 16-bit integer."],["int\nint32_t","A signed two\u2019s complement 32-bit integer."],["unsigned int\nuint\nuint32_t","An unsigned 32-bit integer."],["long\nint64_t\nAll OS: Since\nMetal 2.2.","A signed two\u2019s complement 64-bit integer."],["unsigned long\nuint64_t\nAll OS: Since\nMetal 2.2.","An unsigned 64-bit integer."],["half","A 16-bit floating-point. The half data type must conform to the IEEE 754 binary16 storage format. "],["bfloat\nSince Metal 3.1.","A 16-bit brain floating point. The bfloat data type is a truncated version of float for machine learning applications, using an 8-bit (7 explicitly stored) rather than 24-bit mantissa). "],["float","A 32-bit floating-point. The float data type must conform to the IEEE 754 single precision storage format. "],["size_t","An unsigned integer type of the result of the sizeof operator. This is a 64-bit unsigned integer. "],["ptrdiff_t","A signed integer type that is the result of subtracting two pointers. This is a 64-bit signed integer. "],["void","The void type comprises an empty set of values; it is an incomplete type that cannot be completed. "]],mdxType:"TableView"}),(0,i.kt)("p",null,"Metal \u652f\u6301\uff1a"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"f")," \u6216 ",(0,i.kt)("inlineCode",{parentName:"li"},"F")," \u540e\u7f00\u6307\u5b9a\u5355\u7cbe\u5ea6\u6d6e\u70b9\u6587\u5b57\u503c\uff08\u4f8b\u5982 ",(0,i.kt)("inlineCode",{parentName:"li"},"0.5f")," \u6216 ",(0,i.kt)("inlineCode",{parentName:"li"},"0.5F"),"\uff09\u3002"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"h")," \u6216 ",(0,i.kt)("inlineCode",{parentName:"li"},"H")," \u540e\u7f00\u6307\u5b9a\u534a\u7cbe\u5ea6\u6d6e\u70b9\u6587\u5b57\u503c\uff08\u4f8b\u5982 ",(0,i.kt)("inlineCode",{parentName:"li"},"0.5h")," \u6216 ",(0,i.kt)("inlineCode",{parentName:"li"},"0.5H"),"\uff09\u3002"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bf")," \u6216\u540e\u7f00\u6307\u5b9a\u5927\u8111\u7cbe\u5ea6\u6d6e\u70b9\u6587\u5b57\u503c\uff08\u4f8b\u5982 ",(0,i.kt)("inlineCode",{parentName:"li"},"0.5bf")," \u6216 ",(0,i.kt)("inlineCode",{parentName:"li"},"0.5BF"),"\uff09\u3002"),(0,i.kt)("li",{parentName:"ul"},"\u65e0\u7b26\u53f7\u6574\u6570\u6587\u5b57\u7684 ",(0,i.kt)("inlineCode",{parentName:"li"},"u")," \u6216 ",(0,i.kt)("inlineCode",{parentName:"li"},"U")," \u540e\u7f00\u3002"),(0,i.kt)("li",{parentName:"ul"},"\u6709\u7b26\u53f7\u957f\u6574\u6570\u6587\u5b57\u7684 ",(0,i.kt)("inlineCode",{parentName:"li"},"l")," \u6216 ",(0,i.kt)("inlineCode",{parentName:"li"},"L")," \u540e\u7f00\u3002")),(0,i.kt)("p",null,"\u8868 2. 2 \u5217\u51fa\u4e86\u5927\u591a\u6570\u6807\u91cf\u6570\u636e\u7c7b\u578b\u7684\u5927\u5c0f\u548c\u5bf9\u9f50\u65b9\u5f0f\u3002"))}h.isMDXComponent=!0}}]);